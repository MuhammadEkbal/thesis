\section{Sensorknoten}
\label{sec:arch:sk}
Die Architektur des Sensorknotens beschreibt zum Einen das Zusammenspiel der Peripherie, wie z.B. der Sensorik, mit der Firmware auf dem Mikrocontroller, sowie zum Anderen das des Mikrocontrollers mit der IoT"=Plattform.
Dazu wird die Architektur in zwei Teile gegliedert: Die Hardwarearchitektur, die die Architektur der Hardwarekomponenten beschreibt, und die Softwarearchitektur, die die Architektur der Firmware beschreibt.
Nachfolgend wird zuerst auf die Hardwarearchitektur eingegangen, die dann um die Softwarearchitektur ergänzt wird.

\subsection{Hardwarearchitektur}
Die Hardwarearchitektur des Sensorknotens setzt sich zusammen aus dem Mikrocontroller und der Peripherie, zu der z.B. die Sensorik zählt.
Dabei ist der Mikrocontroller die zentrale Recheneinheit, die die Peripherie verwaltet.
Dafür kommt eine NodeMCU ESP8266 zum Einsatz, die ein WLAN-Modul zur Verfügung hat.
Zudem werden ein Nova SDS011 zur Messung von Feinstaub und ein BME280 zur Messung von Temperatur, Luftfeuchte und -druck verwendet.
Näheres zur Hardware und zum Aufbau steht im Nutzerhandbuch des Sensorknotens (siehe Dokumentation Teil III, Abschnitt 1.4).

\subsection{Softwarearchitektur}
Die Softwarearchitektur des Sensorknotens beschreibt die einzelnen Komponenten und Ressourcen der Firmware, sowie ihr Zusammenspiel mit der IoT"=Plattform.
Ein Überblick der Softwarearchitektur des Sensorknotens ist in \Fig{Architektur_SK_BigPicture} gegeben.

\begin{figure}[!htb]
\centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_BigPicture}
    \caption[Der Überblick über die Softwarearchitektur des Sensorknotens]{Der Überblick über die Softwarearchitektur des Sensorknotens. Pfeile mit durchgezogenen Linien bilden Datenflüsse ab, Pfeile mit gestrichelten Linien Kontrollflüsse.}
    \label{fig:Architektur_SK_BigPicture}
\end{figure}

Die Kernkomponente ist hier der \PicDet{Scheduler}.
Dieser ruft die einzelnen Komponenten, die Tasks, auf, die dann ihre Funktion ausführen.
Dabei ist das Scheduling"=Verfahren auf dieser Modellierungsebene jedoch noch nicht festgelegt.
Die einzige Bedingung ist, dass das Arduino"=Framework, sowie das unterliegende SDK, circa alle 50 Millisekunden aufgerufen wird\footnote{\url{https://arduino-esp8266.readthedocs.io/en/latest/reference.html\#timing-and-delays}}.
Um Messwerte zu erzeugen, wird die Sensorik von der \PicDet{Measuring}"=Komponente angesprochen.
Diese startet eine Messung und versieht die Messwerte anschließend mit einem Zeitstempel aus der \PicDet{TimeProvider}"=Ressource, bevor sie die Messwerte in einen Puffer, dem \PicDet{MeasurementBuffer} schreibt.
Diese werden dann von der \PicDet{MeasurementSender}"=Komponente ausgelesen, um dann von der \PicDet{Transporter}"=Komponente an die IoT"=Plattform oder weiteren Datensenken (z.B. via serieller Schnittstelle) gesendet zu werden.
Die dafür notwendige Netzwerkverbindung wird von der \PicDet{NetworkConnector}"=Komponente hergestellt, die auch regelmäßig den Zustand der Netzwerkverbindung über"=prüft.
Die \PicDet{TimeManager}"=Komponente übernimmt die Synchronisation der Systemzeit, die in der \PicDet{TimeProvider}"=Ressource abgebildet ist, mit der koordinierten Weltzeit (UTC) und der relativen Systemzeit (Betriebszeit).
Zur Verwaltung des Sensornetzwerks senden die \PicDet{StatusInformation}"=Komponente Informationen über die \PicDet{Transporter}"=Komponente an einen konfigurierten Empfänger (z.B. via MQTT an die IoT"=Plattform).
Zu den Statusinformationen zählen die aktuelle Firmware"=Version, die Betriebszeit seit dem letzten Systemstart und der verfügbare Arbeitsspeicher.
Darüber hinaus ist die \PicDet{ConfigHandler}"=Komponente dafür verantwortlich Anfragen bzw. Änderungen an der Konfiguration zu behandeln.
Auch hier findet die Kommunikation über die \PicDet{Transporter}"=Komponente statt, sodass grundsätzlich die Konfiguration von verschiedenen Quellen möglich ist.
Aktuell wird nur die serielle Schnittstelle zuverlässig unterstützt.
Schließlich ist die \PicDet{Updater}"=Komponente für das zyklische Überprüfen auf ein verfügbares Update zuständig.
Ist ein neue Version verfügbar, so lädt die Komponente die zugehörige Update"=Datei via \PicDet{Transporter}"=Komponente herunter und initiiert einen Neustart, bei dem die Aktualisierung der Firmware vorgenommen wird.

In den folgenden Unterkapiteln werden die in \Fig{Architektur_SK_BigPicture} abgebildeten Komponenten detailiert behandelt.

\subsubsection{Scheduler}
Der Scheduler verteilt die CPU"=Ressourcen nach dem Round"=Robin"=Verfahren, sodass jeder Task garantiert pro Umlauf einmal mit Rechenzeit versorgt wird.
Dabei erhält jeder Task ein Zeitfenster von maximal 25 Millisekunden, in dem er mehrmals hintereinander vom Scheduler aufgerufen wird.
Dabei liegt es in der Verantwortung der Tasks, seine Einzelschritte so kurz wie möglich zu halten, um die durch das Framework vorgegebene Schranke von circa 50 Millisekunden nicht zu überschreiten.
Der Task bekommt als zusätzliche Information, ob es sich beim Aufruf um den ersten innerhalb eines Umlaufes handelt.
Darüber hinaus macht er seinen aktuellen Status über den Rückgabewert beim Scheduler bekannt.
Möglich sind \textit{idle} (hat nichts zu tun oder wartet auf eine Ressource), \textit{busy} (ist beschäftigt), \textit{error} (es ist ein unbehebbarer Fehler aufgetreten) und \textit{restartRequested} (Anforderung eines Neustarts).
Auf die unterschiedlichen Werte reagiert der Scheduler entsprechend.
Bei \textit{idle} wird an den nächsten Task weitergegeben, bei \textit{busy} wird der gleiche Task nochmals aufgerufen, falls die Zeitschranke noch nicht überschritten ist und bei \textit{error} sowie \textit{restartRequested} beendet sich der Scheduler, um einen Neustart zu initiieren.
Zwischen der Bedienung zweier Tasks, wird immer einmal an das Framework abgegeben.

\subsubsection{Measuring}
Die Measuring"=Komponente (\Fig{Architektur_SK_Measuring}) ist dafür verantwortlich, alle konfigurierten DataSources zu steuern.
Eine \PicDet{DataSource} ist eine Datenquelle (z.B. ein Sensor, wie der SDS011), die Messdaten liefert, welche vom \PicDet{DataSourceUnificator} zusammengeführt und vom \PicDet{MeasuringTask} in den \PicDet{MeasurementBuffer} geschrieben werden.
Der MeasuringTask bringt zuerst alle DataSources in einen initialisierten Zustand, um dann im vorgegebenen Messintervall Messungen (Measurement) von ihnen abzufragen.
Ein \PicDet{Measurement} besteht aus einem Messzeitpunkt und mehreren MeasurementItems.
Ein \PicDet{MeasurementItem} beschreibt einen Messwert durch seine DataSource, Messeinheit und Messwert mit Größenordnung als Zehnerpotenz.
Hat der MeasuringTask die Measurements aller DataSources erfolgreich abgefragt, so gibt er sie an den DataSourceUnificator, um eine Messung daraus zu erstellen.
Diese zusammengeführte Messung enthält den Mittelwert aller Messzeitpunkte und alle MeasurementItems der einzelnen Measurements und wird in den MeasurementBuffer geschrieben, um die Messwerte zum Senden bereitzustellen.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_Measuring}
    \caption{Architektur der Measuring"=Komponente}
    \label{fig:Architektur_SK_Measuring}
\end{figure}

Der Ablauf für eine einzelne Messung ist in \Fig{Architektur_SK_State_DataSource} dargestellt und verhält sich wie folgt: Zu Beginn bzw. nach jeder Messung errechnet der MeasuringTask anhand des Messintervalls den nächsten Messzeitpunkt.
Mit diesem kann jede einzelne DataSource gesteuert werden, da zu ihnen die Dauer einer Messung und die Vorbereitungszeit bekannt sind.
Initial befindet sich die DataSource im Zustand \PicDet{sleeping}.
Zum passenden Zeitpunkt (nächster Messzeitpunkt minus Messdauer und Vorbereitungszeit) wird die Vorbereitung (\PicDet{Preparation}) angestoßen und die DataSource in den Zustand \PicDet{preparingBusy} versetzt.
Innerhalb der Vorbereitungszeit kann die DataSource interne Übergänge zwischen \PicDet{busy} und \PicDet{waiting} machen.
Im Unterzustand busy soll die Implementation der DataSource aktiv sein, im Unterzustand waiting wartet sie z.B. auf Reaktionen der angeschlossenen Hardware.
Der Unterschied wird verwendet, um dem Scheduler zu signalisieren, ob in diesem Durchgang noch Rechenzeit benötigt wird (Unterscheidung zwischen busy und waiting aktuell nicht implementiert).
Ist die DataSource mit der Vorbereitung fertig, so macht sie einen internen Übergang in den Zustand \PicDet{prepared}.
Danach wird sie vom MeasuringTask in den Zustand \PicDet{measuring} versetzt.
In diesem Zustand findet die Messung statt.
Auch hier können interne Übergänge zwischen busy und waiting gemacht werden (siehe preparing).
Ist die Messung erfolgt, so erfolgt ein interner Übergang in den Zustand \PicDet{measuringFinished}.
Nun kann der MeasuringTask die Messung abholen (\PicDet{takeMeasurement}) und an den DataSourceUnificator übergeben.
Beim Abholen wird die DataSource in den Zustand prepared zurückversetzt.
Ist der passende Zeitpunkt für die nächste Vorbereitung bereits überschritten, so wird die Vorbereitung übersprungen.
Ansonsten wird die DataSource in den Zustand sleeping versetzt (\PicDet{sleep}).
Wird von einer DataSource innerhalb von 3 Sekunden ab dem geforderten Messzeitpunkt keine Messung zurückgeliefert, so fährt der MeasuringTask ohne diese Messung fort.
In der folgenden State Machine ist der Ablauf dargestellt.
Dabei werden interne Übergänge blau dargestellt, extern angestoßene Übergänge schwarz und mit dem entsprechenden Event markiert.
Zustände, die blau markiert sind, bedeuten, dass dem Scheduler \PicDet{busy} geliefert wird (Task benötigt aktuell weitere Rechenzeit).
In den weißen Zuständen wird dem Scheduler unmittelbar nach einem Übergang \PicDet{busy} ansonsten \PicDet{waiting} (Task benötigt für den Moment keine Rechenzeit) zurückgegeben.
Im rot markierten Zustand wird dem Scheduler \PicDet{restartRequested} (Task fordert einen Neustart des Systems an) zurückgegeben.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_State_DataSource}
    \caption{State"=Machine der DataSource"=Komponente}
    \label{fig:Architektur_SK_State_DataSource}
\end{figure}

\subsubsection{TimeManager}
Der \PicDet{TimeManager} (\Fig{Architektur_SK_TimeManager}) verwaltet mehrere \PicDet{TimeSyncStrategies}, die für den Abruf der Realzeit zuständig sind.
Im aktuellen Stand wird nur die erste \PicDet{TimeSyncStrategy} verwendet.
Diese wird zur Zeitsynchronisation aufgerufen und wenn sie erfolgreich war, wird im \PicDet{TimeProvider} markiert, dass die Realzeit gesetzt ist.
War sie nicht erfolgreich, so wird markiert, dass die Realzeit nicht gesetzt ist.
Das Setzen der Systemzeit selbst wird durch die \PicDet{TimeSyncStrategy} übernommen und ist im Framework verborgen.
Für den Abruf der Realzeit über den TimeProvider in anderen Komponenten wird auch Framework"=Funktionalität verwendet.

\begin{figure}[!htb]
\centering
\includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_TimeManager}
\caption{Architektur der TimeManager"=Komponente}
\label{fig:Architektur_SK_TimeManager}
\end{figure}

\subsubsection{MeasurementBuffer}
Der \PicDet{MeasurementBuffer} (\Fig{Architektur_SK_MeasurementBuffer}) ist für die Zwischenpufferung von \PicDet{Measurements} verantwortlich und entspricht einer FIFO"=Warteschlange.
Er erhält die Messungen von der \PicDet{Measuring}"=Komponente und sie werden vom \PicDet{MeasurementSender}, genauer von den \PicDet{DataSinks} (siehe \Fig{Architektur_SK_MeasurementSender}) gelesen.
Dabei hat jede registrierte \PicDet{DataSink} einen eigenen Lesekopf, sodass sie immer die nächste, von ihr noch nicht erfolgreich gesendete, Messung erhält.
Nach Erfolgreichem Versand muss sie die Messung im \PicDet{MeasurementBuffer} freigeben.
Erst wenn alle \PicDet{DataSinks} eine Messung freigegeben haben, wird sie im \PicDet{MeasurementBuffer} gelöscht.
Die Kapazität des Puffers ist nicht begrenzt und führt bei mangelndem Arbeitsspeicher zum Absturz des Systems.
Einem \PicDet{Measurement} ist der Messzeitpunkt (Millisekunden seit Systemstart) und mehrere \PicDet{MeasurementItems} zugeordnet.
Ein \PicDet{MeasurementItem} ist beschrieben durch die zugehörige Datenquelle (z.B. SDS011), der gemessenen Variable (z.B. PM10 in \si{\mu g} pro \si{m^3}), den ermittelten Wert mit Exponenten zur Basis 10 und einer Bewertung des Messwerts (z.B. gültig, ungültig).

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_MeasurementBuffer}
    \caption{Architektur der MeasurementBuffer"=Komponente}
    \label{fig:Architektur_SK_MeasurementBuffer}
\end{figure}

\subsubsection{MeasurementSender}
Der \PicDet{MeasurementSender} (\Fig{Architektur_SK_MeasurementSender}) verwaltet mehrere \PicDet{DataSinks}, die dafür verantwortlich sind, Messwerte an definierte Datensenken zu versenden.
Eine \PicDet{DataSink} bedient dabei genau einen Empfänger, die von verschiedenen Typen sein können.
Unterstützt werden die \PicDet{PGRIODataSink}, die an die innerhalb des Projekts entwickelte IoT"=Plattform sendet und die \PicDet{SerialDataSink}, die Messwerte über die serielle Schnittstelle schickt.
Die Plattform Madavi wird derzeit nicht voll funktionsfähig und Luftdaten.info gar nicht unterstützt.
Jede \PicDet{DataSink} beinhaltet einen \PicDet{Transformer}, der ein \PicDet{Measurement} in das Zielformat transformiert.
Nach der Transformation versendet die \PicDet{DataSink} die Daten über einen geeigneten DataTransporter.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_MeasurementSender}
    \caption{Architektur der MeasurementSender"=Komponente}
    \label{fig:Architektur_SK_MeasurementSender}
\end{figure}

Der Ablauf innerhalb einer \PicDet{DataSink} ist wiefolgt (\Fig{Architektur_SK_State_DataSink}).
Zu Beginn befindet sie sich im Zustand \PicDet{idle}, bis eine Messung im \PicDet{MeasurementBuffer} verfügbar ist.
Dann geht sie über in den Zustand \PicDet{transforming} in dem der zugehörige \PicDet{Transformer} aufgerufen wird.
Schlägt die Transformation fehl, so geht es in \PicDet{idle} zurück.
Ist sie erfolgreich, so gibt es einen Übergang in \PicDet{preparingAck}, in dem die Verarbeitung der Bestätigung vorbereitet wird, dass der Messwert vom Empfänger erhalten wurde.
Danach wird im Zustand \PicDet{readyToSend} der Sendeprozess vorbereitet.
Wird in einem der beiden vorangegangenen Zustände trotz Netzwerkverbindung ein \PicDet{Timeout} von drei Minuten erreicht, so wird ein Systemneustart angestoßen.
Ist das Senden vorbereitet, so wird der transformierte Inhalt der Messung Zeichen für Zeichen an den \PicDet{DataTransporter} versandt.
Schlägt dies fehl, so geht es in \PicDet{idle} zurück, ist es erfolgreich, so geht es in den Zustand \PicDet{waitingForAck}.
Nun wird auf die Quittierung vom Empfänger gewartet.
Ist diese ungültig oder bleibt aus, so geht es zurück in \PicDet{idle}.
Erhält die \PicDet{DataSink} eine gültige Quittierung, so geht es in den Zustand \PicDet{sendingFinished}, um Aufräumarbeiten (insb. das Freigeben der versendeten Messung) zu erledigen.
Danach geht es zurück in \PicDet{idle}.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_State_DataSink}
    \caption{State"=Machine der DataSink"=Komponente}
    \label{fig:Architektur_SK_State_DataSink}
\end{figure}

\subsubsection{Transporter}
Der \PicDet{Transporter} (\Fig{Architektur_SK_Transporter}) ist für die Kommunikation mit externen Systemen verantwortlich.
Dazu verwaltet der \PicDet{TransporterTask} mehrere \PicDet{DataTransporters} die jeweils eine Schnittstelle zu einem externen System bilden.
Mit diesen Systemen kann via HTTP, MQTT oder serieller Schnittstelle kommuniziert werden (auch HTTPS und MQTT over TLS).
Dazu gibt es verschiedene Implementierungen des \PicDet{DataTransporters}.
Jeder \PicDet{DataTransporter} ist einem Host zugeordnet, mit dem er kommuniziert, sodass im laufenden Betrieb mehrere gleichartige \PicDet{DataTransporters} erzeugt werden können.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_Transporter}
    \caption{Architektur der Transporter"=Komponente}
    \label{fig:Architektur_SK_Transporter}
\end{figure}

Die anderen Komponenten des Sensorknotens nutzen diese als Schnittstelle zum externen System, um Daten senden, empfangen oder auf sie lauschen zu können.
Dazu verwenden sie \PicDet{Transportables} die als Nachrichten"=Puffer dienen und beim \PicDet{DataTransporter} für den entsprechenden Vorgang registriert werden.
Das \PicDet{Transportable} wird beim Senden einer Nachricht Zeichen für Zeichen beschrieben und nach Abschluss als gefüllt markiert.
Dann sendet der \PicDet{DataTransporter} die Nachricht aus dem \PicDet{Transportable} Zeichen für Zeichen an das externe System.
Beim Empfangen sendet der \PicDet{DataTransporter} eine Anfrage an das externe System, um anschließend den Inhalt der Antwort Zeichen für Zeichen in das Transportable zu schreiben und es als gefüllt zu markieren.
Danach kann die verwendende Komponente die Nachricht Zeichen für Zeichen aus dem \PicDet{Transportable} auslesen und verarbeiten.
Beim Lauschen ist der \PicDet{DataTransporter} dauerhaft bereit eine bestimmte Nachrichtenart zu empfangen und in das entsprechende \PicDet{Transportable} zu schreiben.
Danach wird das Lauschen auf diese Nachrichtenart beendet, kann aber ggf.
durch die verwendende Komponente erneut abonniert werden.

Das \PicDet{Transportable} verwendet eine \PicDet{CharQueue} um den benötigten Nachrichten"=Puffer zu halten.
Sie stellt Funktionen zum Schreiben eines Zeichens an das Ende vom Puffer und zum Lesen vom Beginn des Puffers bereit (FIFO).
Als Implementierung stehen die \PicDet{DequeCharQueue} bereit, die eine Deque von char kapselt sowie die \PicDet{FileCharQueue}, die den Puffer direkt in einer Datei im Dateisystem abbildet.
Der Vorteil der \PicDet{FileCharQueue} ist, dass sie z.B. beim Download der Update"=Datei direkt die Datei schreiben kann, die nun zur weiteren Verwendung erhalten bleiben kann.

\subsubsection{NetworkConnector}
Der NetworkConnector (\Fig{Architektur_SK_NetworkConnector}) verwaltet mehrere \PicDet{ConnectionManagers}, die für den Aufbau der Netzwerkverbindung zuständig sind.
Dabei geht er alle \PicDet{ConnectionManager} nacheinander mit den folgenden Schritten durch.
Zuerst wird der Status des \PicDet{ConnectionManagers} abgefragt (connected, isConnectingBusy, isConnectingIdle, disconnected).
Ist er \textit{connected}, so wird die \PicDet{NetworkLed} angeschaltet und es wird bei diesem Manager verblieben, bis die Verbindung verlorengeht.
Ist der Status \textit{isConnectingBusy} oder \textit{isConnectingIdle}, so wird die \PicDet{NetworkLed} ausgeschaltet.
Auch im Status \textit{disconnected} wird die \PicDet{NetworkLed} ausgeschaltet, aber zusätzlich ein weiterer Verbindungsaufbau gestartet, bzw. nach drei fehlgeschlagenen Versuchen an den nächsten \PicDet{ConnectionManager} weitergegeben.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_NetworkConnector}
    \caption{Architektur der NetworkConnector"=Komponente}
    \label{fig:Architektur_SK_NetworkConnector}
\end{figure}

Der Ablauf eines einzelnen \PicDet{ConnectionManagers} wird in \Fig{Architektur_SK_State_ConnectionManager} dargestellt.
Initial befindet sich jeder \PicDet{ConnectionManager} im Zustand \PicDet{disconnected}.
Durch einen externen Aufruf von \PicDet{connect} wird er in den Zustand \PicDet{connecting} versetzt.
Dabei kann er sich im Unterzustand \PicDet{busy} oder \PicDet{idle} befinden.
Sie unterscheiden sich darin, ob der ConnectionManager aktiv Schritte zur Verbindungsherstellung unternehmen muss (\PicDet{busy}) oder nur auf Ressourcen gewartet wird (\PicDet{idle}).
Falls die Verbindung nicht hergestellt werden kann (\PicDet{Connection failed}), so gibt es einen internen Übergang nach \PicDet{disconnected}.
Kann sie dagegen hergestellt werden (\PicDet{Connection established}), so wird ein interner Übergang nach \PicDet{connected} unternommen.
Im Zustand \PicDet{connected} kann die Verbindung verloren gehen (\PicDet{Connection lost}), sodass ein interner Übergang nach \PicDet{disconnected} stattfindet.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_State_ConnectionManager}
    \caption{State"=Machine der ConnectionManager"=Komponente}
    \label{fig:Architektur_SK_State_ConnectionManager}
\end{figure}

\subsubsection{StatusInformation}
In der \PicDet{StatusInformation}"=Komponente (\Fig{Architektur_SK_State_StatusInformation}) werden verschiedene Statusinformationen in eine Nachricht geschrieben und via konfiguriertem \PicDet{DataTransporter} versendet.
Auch das Zeitintervall in dem das Senden wiederholt werden soll, ist konfigurierbar.
Im Zustand \PicDet{checkTime} wird überprüft, ob die nächste Nachricht versendet werden soll, falls ja geht es über in den Zustand \PicDet{checkNetworkConnection}.
Hier wird gewartet, bis die Verbindung verfügbar ist, danach wird in \PicDet{createTransportable} ein \PicDet{Transportable} erstellt, in das die zu sendende Nachricht geschrieben wird.
Dann werden in \PicDet{createMsg} die Bestandteile der Statusinformation ermittelt und geschrieben.
Enthalten sind die Firmware"=Version, die Zeit seit Systemstart und der verfügbare Arbeitsspeicher.
Ist die Nachricht erstellt, wird das \PicDet{Transportable} im Zustand \PicDet{startSending} an den \PicDet{DataTransporter} übergeben.
In \PicDet{waitForFinished} wird darauf gewartet, dass die Nachricht vollständig versendet wird.
Sowohl bei Erfolg und Misserfolg geht es wieder in den Zustand \PicDet{checkTime}, sodass nach Ablauf des Intervalls der nächste Versuch gestartet wird.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_State_StatusInformation}
    \caption{State"=Machine der StatusInformation"=Komponente}
    \label{fig:Architektur_SK_State_StatusInformation}
\end{figure}

\subsubsection{ConfigHandler}
Im \PicDet{ConfigHandler} (\Fig{Architektur_SK_State_ConfigHandler}) werden mehrere \PicDet{DataTransporter} registriert, die auf eingehende Befehle bzgl. der Konfiguration lauschen.
Möglich sind das Abfragen der config.json und der credentials.json, sowie jeweils die Übertragung einer neuen Datei.
Abfragen und Ändern der credentials.json ist aus Gründen der Datensicherheit nur via \PicDet{SerialDataTransporter} erlaubt.
Wird eine Änderung der config.json empfangen, so wird das System neugestartet, um die Änderungen zu übernehmen.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_State_ConfigHandler}
    \caption{State"=Machine der ConfigHandler"=Komponente}
    \label{fig:Architektur_SK_State_ConfigHandler}
\end{figure}

Der Ablauf der \PicDet{ConfigHandlers} beginnt im Zustand \PicDet{makeSubscriptions}, in dem für jeden \PicDet{DataTransporter} alle nicht bereits registrierten Nachrichten abonniert werden.
Danach geht es in den Zustand \PicDet{iterateSubscriptions}, in dem für jede registrierte Nachricht überprüft wird, ob der zugehörige \PicDet{DataTransporter} sie empfangen hat.
Ist dies der Fall, so wird der Empfang der Nachricht samt Inhalt verarbeitet.
Bei der Abfrage der config.json wird der Inhalt der Datei über selben \PicDet{DataTransporter} versandt und bei einer Nachricht zur Änderung der Datei, wird diese durch den Inhalt der Nachricht überschrieben (Vorgehen für credentials.json analog).
Durch den Empfang einer Nachricht geht das Abonnement verloren.
Daher geht es nach \PicDet{iterateSubscriptions} zurück in \PicDet{makeSubscription}, um alle Abonnements wiederherzustellen.

\subsubsection{Updater}
Der \PicDet{Updater} (\Fig{Architektur_SK_Updater}) ist dafür verantwortlich, in einem konfiguriertem Intervall zyklisch zu überprüfen, ob eine neue Version der Firmware verfügbar ist.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_Updater}
    \caption{Architektur der Updater"=Komponente}
    \label{fig:Architektur_SK_Updater}
\end{figure}

Dazu fragt er den \PicDet{TimeProvider} ab, um zu prüfen, ob das vorgegebene Intervall seit der letzten Prüfung abgelaufen ist.
Die erste Überprüfung findet unmittelbar nach Systemstart statt.
Bevor nun auf ein neues Update geprüft wird, muss eine Netzwerkverbindung vorhanden sein, deren Status bei der \PicDet{NetworkLed} abgefragt wird.
Danach lädt der \PicDet{CyclicUpdateChecker} eine Metadatei vom Updateserver, in der die verfügbaren Firmware"=Versionen beschrieben sind und überprüft anhand der eigenen Versionsnummer, ob es eine neuere Version gibt.
Ist dies der Fall, so lädt der \PicDet{UpdateFileDownloader} die zugehörige Datei herunter, bevor sie mittels CRC32"=Algorithmus vom \PicDet{UpdateFileValidator} auf korrekte Übertragung überprüft wird.
Wurde die Datei korrekt übertragen, so wird das temporäre \PicDet{UpdateFile} umbenannt und ein Neustart initiiert.
Beim Systemstart wird auf ein vorhandenes \PicDet{UpdateFile} geprüft (wird nur nach Umbenennung gefunden) und das Update durchgeführt.
Anschließend wird das \PicDet{UpdateFile} gelöscht und ein erneuter Systemstart vorgenommen.

Der Ablauf des \PicDet{Updaters} verhält sich wie bereits oben beschrieben und wird durch Abbildung \Fig{Architektur_SK_State_Updater} genauer dargestellt.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1.0\textwidth]{./ressourcen/generiert/Architektur_SK_State_Updater}
    \caption{State"=Machine der Updater"=Komponente}
    \label{fig:Architektur_SK_State_Updater}
\end{figure}

Es soll nur noch die Unterscheidung der Unterzustände \PicDet{checking} und \PicDet{analyzing} des Zustands \PicDet{checkForUpdate} erläutert werden.
Im Zustand \PicDet{checking} wird die Metadatei des Updateservers heruntergeladen, danach wird im Zustand \PicDet{analyzing} die Struktur der Datei analysiert.
Dabei wird überprüft, ob einer der Einträge eine höhere Versionsnummer als die aktuelle Firmware hat.
Ist dies der Fall, so wird der Eintrag für die Verwendung in \PicDet{downloadUpdate} und \PicDet{validateUpdate} bereitgestellt, da er u.a. den Pfad zur Updatedatei auf dem Server und den zugehörigen CRC32"=Hash enthält.

\subsection{Schnittstellen}
Der Sensorknoten verwendet und definiert verschiedene Schnittstellen, um mit externen Systemen zu kommunizieren.
Diese werden zum Großteil in den Beschreibungen anderer Teilsysteme erläutert, da es sich um Schnittstellen handelt, die von diesen Teilsystemen bereitgestellt werden (siehe z.B. \Fref{sec:arch:iot:ssk}).
Daher sollen in diesem Abschnitt die Schnittstelle zum Abfragen und Ändern einer Konfiguration beschrieben werden und das Format der Metadatei auf dem Updateserver, wie es der Sensorknoten verarbeiten kann.

\subsubsection{Konfiguration}
Damit externe System mit dem Sensorknoten kommunizieren können werden verschiedene Endpunkte verwendet.
Dabei stellt der Sensorknoten einerseits Endpunkte bereit, auf denen er lauscht, sodass externe Systeme Nachrichten (ggf. mit Inhalt) an diesen Endpunkt senden können.
Andererseits sendet er an bestimmte Endpunkte, auf denen wiederum das externe System lauschen kann.
Ein Endpunkt ist dabei durch eine Zeichenkette definiert.
Um via serielle Schnittstelle z.B. über den Endpunkt \textit{endpoint} die Nachricht \textit{payload} zu versenden, müssen auf die serielle Schnittstelle die Zeichen \textit{[endpoint] payload} gefolgt von einem '\textbackslash0'-Character geschrieben werden.
Zwischen Endpunkt und Inhalt der Nachricht muss immer ein Leerzeichen stehen.
Für eine Nachricht ohne Inhalt muss der '\textbackslash0'-Character also auf das Leerzeichen folgen.
Um via MQTT die gleiche Nachricht an die IoT"=Plattform zu verschicken, muss der Inhalt \textit{payload} auf dem Topic \textit{pgrio"=sensor/endpoint} veröffentlicht werden (\textit{pgrio"=sensor} muss dabei durch die Kennung des Sensorknotens ersetzt werden).

Zum Abfragen der Konfiguration sind die Endpunkte \textit{config/get} sowie \textit{credentials/get} und zum Ändern \textit{config/change} und \textit{credentials/change} definiert.
Das Ausgeben der aktuellen Konfiguration erfolgt über die Endpunkte \textit{config} und \textit{credentials}.
Empfängt der Sensorknoten eine Nachricht auf dem Endpunkt \textit{config/get} bzw. \textit{credentials/get} (nur für serielle Schnittstelle unterstützt), so wird der Inhalt der Nachricht nicht beachtet und die aktuelle \filename{config.json} bzw. \filename{credentials.json} wird an den Endpunkt \textit{config} bzw. \textit{credentials} gesendet.
Empfängt der Sensorknoten eine Nachricht auf dem Endpunkt \textit{config/change} bzw. \textit{credentials/change} (nur für serielle Schnittstelle unterstützt), so muss der Inhalt der Nachricht mit der zu übernehmenden Konfiguration gefüllt sein.
Dieser Inhalt wird ohne Überprüfung in die Datei \filename{config.json} bzw. \filename{credentials.json} geschrieben, d.h. Fehlkonfigurationen sind möglich und werden nicht abgefangen.
Nach dem Empfang einer neuen \filename{config.json} wird der Sensorknoten neugestartet.

Das Ändern der Konfiguration ausgehend von der IoT"=Plattform via MQTT wird nicht unterstützt.
Dabei kommt es aufgrund eines zu kleinen Eingangspuffers zu Fehlern.

\subsubsection{Updateserver}
Auf dem Updateserver muss über den Pfad \filename{/availableUpdates.json} eine Datei mit Metainformationen zu verfügbaren Firmware"=Versionen abrufbar sein.
Auf der Wurzelebene muss die JSON"=Datei ein Schlüssel"=Wert"=Paar mit Schlüssel \textit{updates} enthalten.
Als Wert wird eine geordnete Liste von Firmware"=Versionen angegeben.
Jede Firmware"=Version besteht aus folgenden Schlüssel"=Wert"=Paaren:
\begin{itemize}
    \item \textit{\_v}: Die Version des Formats, aktuell immer \textit{"'1"'}
    \item \textit{path}: Der Pfad zur Update"=Datei auf dem Server
    \item \textit{version}: Die Version der Firmware
    \item \textit{crc32}: Der CRC32"=Hash der Update"=Datei, Angabe mit Kleinbuchstaben
    \item \textit{description}: Eine Beschreibung der Version, durch den Sensorknoten unbeachtet
\end{itemize}

Beispiel:

\begin{lstlisting}[language=json,basicstyle=\footnotesize]
{
  "updates": [
    {
      "_v": "1",
      "path": "/files/main_v1_0_190917135858.bin",
      "version": "1.0.190917135858",
      "crc32": "f8a8b877",
      "description": "Timestamp Bugfix"
    },
    {
      "_v": "1",
      "path": "/files/main_v1_0_190911205242.bin",
      "version": "1.0.190911205242",
      "crc32": "d96eb653",
      "description": "Initial Release"
    }
  ]
}
\end{lstlisting}
