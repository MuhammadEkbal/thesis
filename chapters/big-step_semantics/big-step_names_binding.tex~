% mainfile: ../../Refinement.tex
Since we already talked about objects and subjects of actions, it is useful to define functions which calculate them from the actions and especially from traces.

\begin{definition}[Subjects and objects]
\label{def_sub_obj}
	We define $\subF: \actions\setminus\set{\tau} \rightarrow \names$ as the function which collects the \findex[subject]{subjects} and $\objF: \actions\setminus\set{\tau} \rightarrow \names$ for the \findex[object]{objects} of an action such that
	\begin{equation*}
		\begin{aligned}
			\begin{array}{lcl}
				\sub{\out{a}{x}} & \define & a \\
				\sub{\bout{a}{x}} & \define & a \\
				\sub{\inpa{a}{x}} & \define & a 
			\end{array}
		\end{aligned}\quad\quad\quad\quad\quad\quad
		\begin{aligned}
		\begin{array}{lcl}
			\obj{\out{a}{x}} & \define & x \\
			\obj{\bout{a}{x}} & \define & x \\
			\obj{\inpa{a}{x}} & \define & x 
		\end{array}
	\end{aligned}
\end{equation*}
holds. With those functions, we define $\subF: \tr \rightarrow \pom{\names}$ with
	\[\sub{s} \define \set[\exists\alpha\in{}s: x=\sub{\alpha}]{x\in\names},\]
which collects the subjects of a trace and $\objF: \tr \rightarrow \pom{\names}$ with
\[\obj{s} \define \set[\exists\alpha\in{}s: x=\obj{\alpha}]{x\in\names},\]
which collects the objects.
\end{definition}

Furthermore, we %already know what the meaning of free and bound names of actions as well as of processes is, it is consistent to
define the \findex[free name!trace]{free} and \findex[bound name!trace]{bound names} of a trace. This definition intuitively fits to the definition of free and bound names of processes in \refSec{sec_pi_names_substitution}.

\begin{definition}[Bound and free names of a trace]
\label{def_bound_free_names_traces}
The \findex[bound name!trace]{bound names} of a trace $t\in\tr$ are defined by
\[\bn{t}\define\bigcup_{\alpha\in{}t}\bn{\alpha}.\]
Thus, all names are collected, which occur as an object of a bound output action within the trace. Furthermore, with
\[\fn{t}\define{}\set[n\nin\bn{t}]{n\in\n{t}}\]
we define the \findex[free name!trace]{free names} of a trace $t\in\tr$ by the set of all the other names, which do not occur bound in $t$. Once more, the \findex[name!trace]{names} of a transition $t\in\tr$ are denoted by $
\n{t}\define{}\fn{t}\cup\bn{t}$.
%\end{align*}
%	\begin{equation*}	
%		\begin{aligned}			
%			\begin{array}{lcl}
%				\fn{\eseq} & \define & \emptyset \\
%				\fn{\seqconc{\seq{\out{a}{x}}}{t}} & \define & \fn{t}\cup\set{a,x} \\
%				\fn{\seqconc{\seq{\inp{a}{x}}}{t}} & \define & \left(\fn{t}\cup\set{a}\right)\setminus\set{x} \\
%				\fn{\seqconc{\seq{\bout{a}{x}}}{t}} & \define & \left(\fn{t}\cup\set{a}\right)\setminus\set{x} 
%			\end{array}
%		\end{aligned}\quad
%		\begin{aligned}
%			\begin{array}{lcl}
%				\bn{\eseq} & \define & \emptyset \\
%				\bn{\seqconc{\seq{\out{a}{x}}}{t}} & \define & \bn{t} \\
%				\bn{\seqconc{\seq{\inp{a}{x}}}{t}} & \define & \bn{t}\cup\set{x} \\
%				\bn{\seqconc{\seq{\bout{a}{x}}}{t}} & \define &\bn{t}\cup\set{x} 
%			\end{array}
%		\end{aligned}
%	\end{equation*}
\end{definition}

Like the connection between the operational semantics and the free names of its processes, there is also a connection between traces and the free names of its components.

\begin{lemma}[Big-step semantics and free names]
\label{lem_bigstep_fn}
Given processes $P,Q\in\procs$ and a trace $t\in\tr$, then
\[\ec{P}\bigstep{t}\ec{Q} \text{ implies } \fn{Q}\subseteq\fn{P}\cup\n{t}\]
holds.
\end{lemma}
\begin{prf}
Let $P_1,P_n\in\procs$ and $t\in\tr$ with $\ec{P_1}\bigstep{t}\ec{P_n}$ and $\len{t}=n-1$ for some $n\in\N$ . Hence, there are processes $P_2,\ldots,P_{n-1}\in\procs$ such that $\ec{P_1}\bigstep{\seq{t_1}}\ec{P_2}\bigstep{\seq{t_2}}\cdots\bigstep{\seq{t_{n-2}}}\ec{P_{n-1}}\bigstep{\seq{t_{n-1}}}\ec{P_n}$. For every $\tau$ step within the big-steps we know from \refLem{lem_trans_fn} Equation~(\ref{eq_trans_fn_tau}) that the free names of the resulting process are a subset of the free names of the starting one. The same lemma also yields for every $i\in\set{1,\ldots,n-1}$ that $\fn{P_{i+1}}\subseteq{}\fn{P_i}\cup\n{t_{i}}$. Thus, $\fn{P_n}\subseteq{}\fn{P_{n-1}}\cup\n{t_{n-1}}\subseteq\left(\fn{P_{n-2}}\cup\n{t_{n-2}}\right)\cup\n{t_{n-1}} \subseteq \cdots \subseteq\fn{P_1}\cup\n{t}$, since $\n{t}=\bigcup_{i\in{}\set{1,\ldots,n-1}}\n{t_i}$ holds.
\end{prf}

Note that in particular the inclusion is an over-approximation. Consider, for instance, $P\define\procpar{\inp{a}{b}.\out{c}{d}}{\out{x}{y}.\inp{z}{w}}$. Then, $\ec{P}\bigstep{\seq{\inpa{a}{b},\outa{x}{y}}}\ec{Q}$ with $Q\define{}\procpar{\out{c}{d}}{\inp{z}{w}}$ and $\fn{Q}=\set{c,d,z}\subseteq\set{a,c,d,x,y,z}\cup\set{a, b, x, y}=\fn{P}\cup\n{t}$. Moreover, $\ec{P}\bigstep{\seq{\inpa{a}{r}, \outa{c}{d}, \outa{x}{y}, \inpa{z}{s}}}\ec{\procpar{\proczero}{\proczero}}$ and so $\emptyset\subseteq\set{a,c,d,x,y,z}\cup\set{a, r, c,d,x,y,z,s}$.

Furthermore, it is helpful -- especially for \refLem{lem_from_resset_to_res} -- to define a function which replaces every occurrence of an output action in a trace by a bound output action for a given name.

\begin{definition}[Binding]
\label{def_binding}
	We define the \findex{binding function} $\bindF: \names\times\actions \rightarrow \actions$, with
	\begin{align*}
		\begin{array}{lcl}
			\bind{a}{\tau} & \define & \tau \\
			\bind{a}{\bout{b}{x}} & \define & \bout{b}{x} \\
			\bind{a}{\inpa{b}{x}} & \define & \inpa{b}{x} \\
			\bind{a}{\out{b}{x}} & \define & \left\{\begin{array}{ll}
									\bout{b}{x} & \falls\; a=x \\
									\out{b}{x} & \text{else}
								\end{array} \right.
		\end{array}
	\end{align*}
	such that it only replaces an output action with its corresponding bound output action, if the given name is the object of the action.

Furthermore, for traces $\bindF: \names\times\tr \rightarrow \tr$ is defined as
\begin{align*}
\bind{a}{s} \define \seq{s'_1,s'_2,\dots} \text{ with }  s'_i =\left\{
								\begin{array}{cll}
									 \bind{a}{s_i} & \text{ if } \nexists{}j\in\N\colon{}&j<i \wedge a\in\obj{s_j} \\
													& & \wedge{}s_j\in\outA\cup\boutA \\
									s_i & \text{else}&
								\end{array}\right.
\end{align*}
for all $i\in\set{1,2,\dots}$. Moreover, we would like to bind a name in a whole set of traces such that $\bindF: \names\times\pom{\tr} \rightarrow \pom{\tr}$ is defined with
\[\bind{a}{X} \define \set[\exists s'\in{}X: s=\bind{a}{s'}]{s\in\tr}\]
as a function which binds a name to a whole trace set by applying the binding function to every trace within the set.
\end{definition}

Note that just the first occurrence of the name as an object of an output action is replaced by the binding function. This is because by \refConv{conv_uni_bn_traces} we will stipulate that every bound name within a trace is unique.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% OLD: wrong explanation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{old}{incorrect explanation why there can be at least one occurrence of a bound output}
there can be at most one occurrence of an output action in a trace which have to be replaced. This is because there is just one rule in the definition of the operational semantics (\refDef{def_early_trans_system}) which produces a bound output action and thereby the restriction operator is afterwards omitted and no bound output action, without a restriction. With \refConv{conv_uni_bn}, we know that the given name cannot occur twice bounded in a process, so another bound output action for the same name cannot exist.
\end{old}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% OLD: end wrong explanation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
