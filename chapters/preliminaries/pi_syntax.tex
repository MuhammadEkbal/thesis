% mainfile: ../../Refinement.tex
Let $\names$ be the countably infinite set of \findex[name]{names}, with typical representatives as lower case letters like $a,b,c,x,y,z,\ldots\in\names$ and let $\conames\define\set[a\in\names]{\overline{a}}$ be the set of \findex{co-names}. In communications the names of $\names$ are used as \findex[channel]{channels} as well as as \findex[message]{messages} / \findex[object]{objects}.

With the help of these names we can define \findex[prefix]{prefixes} of \picalc{} processes. The possible prefixes $\pi$ of a \picalc{} process are
\[\pi \syntdef \inp{x}{y} \ebnf \out{x}{y} \ebnf \tau,\]
with $x,y\in\names$. The prefix $\out{x}{y}$ stands for the \index{output!prefix}\findex[prefix!output]{output prefix}, which means the process can send the name $y$ over the channel $x$. For receiving a value $y$ along the channel $x$, the \index{input!prefix}\findex[prefix!input]{input prefix} $\inp{x}{y}$ is used. After receiving, every occurrence of $y$ in the remaining process is replaced by the received name. The third prefix is called the \index{prefix!silent}\findex[silent!prefix]{silent prefix} and means that the process performs an internal step.

Processes do not simply consist of prefixes, they also can for example be composed in parallel or appear in an alternative. The full syntax of \picalc{} processes is given in \refDef{def_syntax}. To define a recursion with parameters, there is the need for \findex[process!identifier]{process identifiers} typically denoted by upper case letters $A,B,C,\ldots$ and an abbreviation for a finite list of names. Thus, we can write $\vec{a}$ for a parameter list $a_1,a_2,\ldots,a_n$ for some $n\in\N\setminus\set{0}$ and $a_1,\ldots,a_n\in\names$. Additionally, we treat $\vec{a}$ as a set $\set{a_1,a_2,\ldots,a_n}$, whenever it is needed and no confusion arises. Moreover, in the \findex{recursive definition} $\procdef{A}{\vec{w}}\define{}P$ with the process identifier $A$ and a process $P$, the elements of $\vec{w}$ must be pairwise distinct.

\begin{definition}[Syntax]
\label{def_syntax}
The syntax of \picalc{} \findex[process]{processes} -- typically denoted by $P,Q,R,\ldots$ -- is defined inductively: 
\begin{align*}
 M & \syntdef \proczero \ebnf \pi.P \ebnf \procchoice{M_1}{M_2} \ebnf \procres{z}{M} \\
 P & \syntdef M \ebnf \procpar{P_1}{P_2} \ebnf \procres{z}{P} \ebnf \proccall{A}{\vec{v}}.
\end{align*}
The set of all \picalc{} processes is denoted by $\procs$. We call $M$ a \findex{summation} or \findex{sum} and the set of all summations is denoted by $\sums$. We further assume that there is a recursive definition $\procdef{A}{\vec{w}}\define{}Q$ for every $\proccall{A}{\vec{v}}$ and define that every process itself relies on a finite number of process identifiers.
\end{definition}

To gain an intuition of the intended interpretation of the syntax, at first we give a brief informal description of the behavior of the possible types of processes, before we define an operational semantics in \refSec{sec_pi_op_sem}.

The process $\proczero$ is called the \index{process!stop}\findex{stop process} or \findex{inaction} and stands for the process without behavior. Often we will -- as a convention -- omit a pending $\proczero$ and accordingly write, for example, $\procpar{\out{x}{y}}{\left(\procchoice{\inp{x}{z}}{\tau}\right)}$ instead of $\procpar{\out{x}{y}.\proczero}{\left(\procchoice{\inp{x}{z}.\proczero}{\tau.\proczero}\right)}$.

Let $\pi$ be one of the three defined prefixes and $P\in\procs$, then we call $\pi.P$ a \index{process!prefix}\findex[prefix!process]{prefix process}. The prefixes represent the communication possibilities of a process. As described we can send or receive values over a given channel or perform an internal step. From the semantical view we call it an \findex[action]{action}, if such a prefix is performed. Every action resulting from handling a prefix apart from the silent prefix will be called an \index{action!observable}\findex[observable action]{observable action}, since this behavior is visible to the environment. Thus, a process $P'\define\out{x}{y}.P$ has to perform an \findex[action!output]{output action} $\out{x}{y}$ before it behaves like $P$. Furthermore, we call $x$ the \findex{subject} and $y$ the \findex{object} or \findex{parameter} of a prefix $\out{x}{y}$ or $\inp{x}{y}$, as well as of the corresponding actions. The third prefix performs a \index{action!silent}\findex[silent!action]{silent action} or -- in contrast to the other prefixes -- an \index{action!unobservable}\findex{unobservable action} and is used to describe an \index{action!internal}\findex{internal action}. Thus, $\pi.P$ performs the $\pi$ prefix and after that it behaves like $P$ or in case that $\pi$ is an input prefix it behaves like a process $P'$, where every occurrence of the object of the prefix is replaced by the received name. For example the process $\inp{a}{x}.\out{x}{y}.\proczero$ can evolve with the visible \findex[action!input]{input action} $\inpa{a}{b}$ to the process $\out{b}{y}.\proczero$. Depending on the prefix $\pi$ we also call a process $\pi.P$ an \index{process!input}\findex[input!process]{input process}, \index{process!output}\findex[output!process]{output process} or \index{process!$\tau$}\findex{$\tau$ process}.

For a \index{process!parallel}\findex{parallel composition} $\procpar{P_1}{P_2}$ with $P_1,P_2\in\procs$ the behavior is an interleaving of the behavior of the process $P_1$ and $P_2$, with the added possibility of a communication between the two parts over a common channel. Consider, for example, $P_1\define\inp{x}{y}.\out{y}{z}$ and $P_2\define\out{x}{a}.\out{b}{b}$, then $P\define\procpar{P_1}{P_2}$ can evolve invisibly to $\procpar{\out{a}{z}}{\out{b}{b}}$, since $P_1$ and $P_2$ communicate over the common channel $x$ by sending the name $a$. Furthermore, $P_1$ and $P_2$ can act independently, so if, for instance, $P_2$ performs the visible action $\out{x}{a}$, $P$ can also perform the action $\out{x}{a}$ and thus evolve to $\procpar{\inp{x}{y}.\out{y}{z}}{\out{b}{b}}$.

The \index{process!restriction}\findex{restriction} $\procres{z}{P}$ for a process $P\in\procs$ and a name $z\in\names$, binds the name $z$ to the process $P$. Thus, the scope of $z$ is restricted to $P$. This concept can be seen similarly to the notion of private variables in the context of programming languages. We call $z$ \findex[restricted name]{restricted}\index{name!restricted}, since the name $z$ may only be used within $P$ and not for a communication with the environment. For instance $\procres[a]{z}{\procpar{\inp{z}{x}}{\out{z}{y}}}$ can only invisibly communicate over $z$, whereby $\procres[a]{z}{\out{x}{y}.\out{z}{a}}$ can perform the visible output action $\out{x}{y}$, since $z$ is not a part of the action. But there is one exception from this rule. It is also possible to widen the scope of a restricted name $z$ -- called \findex{scope extrusion} --, if the restricted name is passed via a nonrestricted channel. For instance consider $P\define\procres[a]{z}{\out{x}{z}.\inp{z}{y}}$ and $Q\define\inp{x}{a}.\out{a}{b}$, then $\procpar{P}{Q}$ can communicate over channel $x$ so that afterwards the former just to $P$ known channel $z$ is also known, but restricted, in the whole remaining process $\procres[a]{z}{\procpar{\inp{z}{y}}{\out{z}{b}}}$.

A \findex[process!choice]{choice process}, or simply \findex{choice}, is written by $\procchoice{M_1}{M_2}$ with $M_1,M_2\in\sums$. From the definition we know that every participant of the choice must either be an inaction, a prefix, a restriction of a sum or simply a sum itself. Since a sum with a restriction is also possible within a choice, this variant is a slightly adapted version of a \findex[guarded choice]{guarded choice}. A choice process $\procchoice{M_1}{M_2}$ with $M_1,M_2\in\sums$ has the possibility to behave like the process $M_1$ or like $M_2$. But if one process is chosen, the behavior of the other is no longer taken into account. Thus, for instance, the process $\procchoice{\out{a}{b}.\out{b}{c}.\proczero}{\out{x}{y}.\out{y}{z}.\proczero}$ can evolve to the process $\out{b}{c}.\proczero$ or to $\out{y}{z}.\proczero$.

Finally, $\proccall{A}{\vec{v}}$ with a process $P\in\procs$ and a recursive definition $\procdef{A}{\vec{w}}\define{}P$ is a \findex[process!call]{process call}, or simply \findex{call}. The behavior of the call $\proccall{A}{\vec{v}}$ is the same as the behavior of the process $P'$, where $P'$ results of $P$ by the simultaneous replacement of every occurrence of the elements of $\vec{w}$ by the elements of $\vec{v}$. Hence, $\vec{v}$ and $\vec{w}$ have to be of the same length.

As a convention, we agree that the unary operators bind stronger than the binary ones, and also the sum binds more tightly than the parallel composition. Additionally, the prefix operator binds stronger than restriction. Thus, we can, for example, write $\procpar{\procres{y}{\out{x}{y}.P}}{\procchoice{\inp{a}{b}.Q}{M_1}}$ with $P,Q\in\procs$ and $M_1\in\sums$ instead of $\procpar{\procres[a]{y}{\out{x}{y}.P}}{\left(\procchoice{\left(\inp{a}{b}.Q\right)}{M_1}\right)}$. Furthermore, we agree that we can abbreviate a sequence of restrictions, for example $\procres[()]{a_1}{\ldots \procres[()]{a_n}{P}\ldots}$, by $\procres[()]{a_1,\ldots,a_n}{P}$.

%The limiting of the operators, which are used to build the processes with, leads to some interesting syntactical subclasses of the \picalc{}.
We present two interesting syntactical subclasses of the \picalc{}: the subclass of \findex{restriction-free} processes and the subclass of \findex{recursion-free} ones, which are already defined, for example, in \cite{meyer}.

\begin{definition}[Restriction-free]
\label{def_res_free}
A process $P'\in\procs$, which is constructed from the syntax of \refDef{def_syntax} without using the $\procres{z}{M}$ with $M\in\sums$ and $\procres{z}{P}$ with $P\in\procs$ parts, is called \findex{restriction-free}. The set of all restriction-free processes is denoted by $\procsresf$.
\end{definition}

Thus, there is no restriction operator within a restriction-free process. Analogously, we define the recursion-free process by not using the call operator from \refDef{def_syntax}, while building the process.

\begin{definition}[Recursion-free]
\label{def_res_free}
A process $P\in\procs$, which is constructed from the syntax of \refDef{def_syntax} without using the $\proccall{A}{\vec{v}}$ part, is called \findex{recursion-free}. The set of all recursion-free processes is denoted by $\procsrecf$.
\end{definition}

These subclasses helps us in \refSec{sec_de_sem_trace_prop_comp} to investigate the compositionality of our in \refSec{sec_de_sem_trace_def} defined semantics.
