% mainfile: ../../Refinement.tex
As already seen in the informal description of the syntax of the \picalc{}, the restriction operator as well as the input prefix binds a name to a process. Intuitively, the \index{name!bound}\findex[bound name]{bound names} of a process are those, which occur as an object in an input prefix and those who are restricted within a process. The other names, which additionally appear in a process, are called \index{name!free}\findex[free name]{free names}. Formally, we introduce with \refDef{def_bound_free_names} two functions to calculate the bound respectively free names of a process. 

\begin{definition}[Bound and free names of a process]
\label{def_bound_free_names}%|see{free name}
Given $P,Q\in\procs$ and $M,N\in\sums$. Furthermore, let $a,b\in\names$. The function $\bnF:\procs\rightarrow\pom{\names}$ collects all \index{name!bound}\findex[bound name!process]{bound names} of a process and similarly the function $\fnF:\procs\rightarrow\pom{\names}$ computes the \index{name!free}\findex[free name!process]{free names} of a process. Both are inductively defined as follows:
\begin{equation*}	
	\begin{aligned}			
		\begin{array}{lcl}
			\bn{\proczero} &\define& \emptyset \\
			\bn{\tau.P} &\define& \bn{P}\\
			\bn{\out{a}{b}.P} &\define& \bn{P} \\
			\bn{\inp{a}{b}.P} &\define&\set{b}\cup\bn{P}\\
			\bn{\procchoice{M}{N}} &\define& \bn{M}\cup\bn{N}\\
			\bn{\procpar{P}{Q}} &\define& \bn{P}\cup\bn{Q} \\
			\bn{\procres{a}{P}} &\define& \set{a}\cup\bn{P} \\
			\bn{\proccall{A}{\vec{v}}} &\define& \emptyset
		\end{array}
	\end{aligned}
	\begin{aligned}
		\begin{array}{lcl}
			\fn{\proczero} &\define& \emptyset \\
			\fn{\tau.P} &\define &\fn{P} \\
			\fn{\out{a}{b}.P} &\define& \set{a,b}\cup\fn{P} \\
			\fn{\inp{a}{b}.P} &\define& \set{a}\cup\left(\fn{P}\setminus\set{b}\right) \\
			\fn{\procchoice{M}{N}} &\define &\fn{M}\cup\fn{N} \\
			\fn{\procpar{P}{Q}} &\define& \fn{P}\cup\fn{Q} \\
			\fn{\procres{a}{P}}& \define& \fn{P}\setminus\set{a} \\
			\fn{\proccall{A}{\vec{v}}}& \define& \vec{v}.
		\end{array}
	\end{aligned}
\end{equation*}
Furthermore, we call $\nF:\procs\rightarrow\pom{\names}$ with $\n{P}\define \fn{P}\cup\bn{P}$ for all $P\in\procs$ the \findex[name!process]{names} of a process $P$.
\end{definition}

According to that, we stipulate that for a recursive definition $\procdef{A}{\vec{w}}\define P$, the free names of $P$ are included in the parameter list; thus, $\fn{P}\subseteq\vec{w}$. This simplifies the handling of a recursive call and so the definition of the free names of a recursive call fits to this convention.

%According to that, we stipulate that for a recursive definition $\procdef{A}{\vec{w}}\define P$, the free names of $P$ are included in the parameter list; thus, $\fn{P}\subseteq\vec{w}$. This simplifies the handling of a recursive call and its names by not complicating its definition. Thus, the definition of the free names of a recursive call fits to this convention.
%Furthermore, we define all parameters of a call as free. From the definition of a call we know that the free names of the process must occur as parameters of the call, but the possibility for more parameters is not excluded. Since those cannot occur bound in the process -- bound names are unique (\refConv{conv_uni_bn})--, they cannot occur at all. Hence there is no problem by calling them also free.

For the informal description of the semantics of the input process and the process call, we already used an idea of the replacement of names in a process. We now give a formal definition of a function, which replaces the free names of a process by some other names.

\begin{definition}[Substitution]
\label{def_substitution}
We define a \findex{substitution} $\substF:\names\rightarrow\names$, as the simultaneous replacement of names, that is, $\substF$ maps a finite number of names to other names and behaves as the identity otherwise. We write $\subs{a_1,\ldots,a_n}{b_1,\ldots,b_n}$ for some $n\in\N$ and $a_1,\ldots,a_n,b_1,\ldots,b_n\in\names$ for the substitution
	\[\substF(x) =\left\{\begin{array}{ll}
									a_i & \falls\; x=b_i \;\text{and} \; i\in\set{1,\ldots,n}\\
									x & \text{else}
									\end{array}
								\right.\]
	as an abbreviation. Furthermore, we define the \findex[name!substitution]{names} of such a substitution with $\n{\subs{a_1,\ldots,a_n}{b_1,\ldots,b_n}}\define\set{a_1,\ldots,a_n,b_1,\ldots,b_n}$, the \index{substitution!support}\findex{support} with $\supp{\sigma}\define\set[\substF(x)\neq{}x]{x\in\names}$ and the \index{substitution!co-support}\findex{co-support} of a such a substitution by $\cosupp{\sigma}\define\set[x\in\supp{\substF}]{\substF(x)\in\names}$. Hence, $\n{\substF}=\supp{\substF}\cup\cosupp{\substF}$. 

If the substitution $\sigma$ just interchanges two names, for example, $\sigma=\subs{a,b}{b,a}$ we call $\sigma$ a \findex{transposition} and abbreviate it by $\transp{a}{b}$. Furthermore, we define the application of a substitution $\sigma$ on a set of names $X\subseteq\names$ by $X\sigma\define\set[x\in{}X]{\sigma(x)}$.

The \index{substitution!process}\findex[application substitution!process]{application} of a substitution $\substF$ to a process $P\in\procs$, with $\n{\sigma}\cap\bn{P}=\emptyset$, is written as $P\substF\in\procs$ and is inductively defined
	\begin{equation*}	
		\begin{aligned}			
			\begin{array}{lcl}
				\proczero\substF & \define & \proczero \\
				\subst{\tau.P_1} & \define & \tau.\left(P_1\substF\right) \\
				\subst{\inp{x}{y}.P_1} & \define & \inp{\substF(x)}{y}.\left(P_1\substF\right) \\
				\subst{\out{x}{y}.P_1} & \define & \out{\substF(x)}{\substF(y)}.\left(P_1\substF\right)
			\end{array}
		\end{aligned}
		\begin{aligned}
			\begin{array}{lcl}
				\subst{\procchoice{M_1}{M_2}} & \define & \procchoice{M_1\substF}{M_2\substF} \\
				\subst{\procpar{P_1}{P_2}} & \define & \procpar{P_1\substF}{P_2\substF} \\
				\subst{\procres{a}{P_1}} & \define & \procres[a]{a}{P_1\substF}\\
				\proccall{A}{\vec{v}}\substF & \define & \proccall{A}{\vec{v}\substF}
			\end{array}
		\end{aligned}
	\end{equation*}
for $x,y,a\in\names$, $\vec{v}\subseteq\names$, $P_1,P_2\in\procs$ and $M_1,M_2\in\sums$.
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% START SAFE SUBSTITUTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{old}{Not needed definition of save substitution}
For the definition of the operational semantics as well, there is the need for a formal definition of the informally described replacement of names for example for the input prefix and the process call. To avoid the often used substitution where -- as a convention -- the names of the substitution differs from the names already occurring bound in the process (for example used in \cite{sangiorgi}), we accord to the substitution Lu\'{i}s Caires and Luca Cardelli presented in \cite{caires}. So we explicitly change the bound names of a process while applying a substitution so that no unintended capture of names by binders can occur.

Hence the secure substitution replaces names, no matter if they are bound, free or even existing in the process.
\begin{definition}[Safe substitution]
\label{def_substitution}
	We define a \findex{safe substitution} or simply \findex{substitution} $\substF:\names\rightarrow\names$, as the simultaneous replacement of names, such as $\substF$ maps a finite number of names to other names and behaves as identity otherwise. As abbreviation we write $\subs{a_1,\ldots,a_n}{b_1,\ldots,b_m}$ for some $n,m\in\N$ and $a_1,\ldots,a_n,b_1,\ldots,b_m\in\names$ for the substitution
	\[\substF\left(x\right) =\left\{\begin{array}{ll}
									a_i & \falls\; x=b_i \;\text{and} \; i\leq{}n\\
									x & \text{else}
									\end{array}
								\right..\]
	Furthermore we define the names of such a substitution as: $\n{\subs{a_1,\ldots,a_n}{b_1,\ldots,b_m}}\define\set{a_1,\ldots,a_n,b_1,\ldots,b_m}$. 

The \index{substitution!process}\findex[application substitution!process]{application} of a substitution $\substF$ to a process $P\in\procs$ is written $P\substF\in\procs$ and is inductively defined
	\begin{equation*}	
		\begin{aligned}			
			\begin{array}{lcl}
				\proczero\substF & \define & \proczero \\
				\subst{\tau.P} & \define & \tau.\left(P\substF\right) \\
				\subst{\inp{x}{y}.P} & \define & \inp{\substF\left(x\right)}{p}.\left(\subst{P\subs{p}{y}}\right) \;\text{for}\;p\nin\left(\fn{P}\cup\set{x}\cup\n{\substF}\right) \\
				\subst{\out{x}{y}.P} & \define & \out{\substF\left(x\right)}{\substF\left(y\right)}.\left(P\substF\right) \\
%			\end{array}
%		\end{aligned}\quad
%		\begin{aligned}
%			\begin{array}{lcl}
				\subst{\procchoice{P}{Q}} & \define & \procchoice{P\substF}{Q\substF} \\
				\subst{\procpar{P}{Q}} & \define & \procpar{P\substF}{Q\substF} \\
				\subst{\procres{a}{P}} & \define & \procres[a]{p}{\subst{P\subs{p}{a}}} \;\text{for}\;p\nin\left(\fn{P}\cup\n{\substF}\right)\\
				\proccall{A}{v_1,\ldots,v_n}\substF & \define & \proccall{A}{\substF\left(v_1\right),\ldots,\substF\left(v_n\right)} \\
			\end{array}
		\end{aligned}
	\end{equation*}
for $x,y,a,v_1,\ldots,v_n\in\names$ and $P,Q\in\procs$.
\end{definition}
\end{old}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% END SAFE SUBSTITUTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% START TRANSPOSITION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{old}{Not needed definition for transposition}
\begin{definition}[Transposition]
\label{def_transposition}
	We define a \findex{transposition} $\theta_X:\names\rightarrow\names$ noted $\transp{m}{n}_X$ for some $n,m\in\names$ and $X\subset\names$ as the interchanging of the names such that
	\[\transp{m}{n}_X\left(x\right) =\left\{\begin{array}{ll}
					n & \falls\; x=m \;\text{and} \; m,n\nin{}X\\
					m & \falls\; x=n \;\text{and} \; m,n\nin{}X\\
					x & \text{else}
					\end{array}
				\right.\]
	holds with $\n{\transp{m}{n}_X}\define\set{m,n}$ the names of the transposition. Furthermore we define the transposition $\theta_X:\procs\rightarrow\procs$ also noted $\transp{m}{n}_X$ for some $n,m\in\names$ and $X\subset\names$ inductively for processes:
	\begin{equation*}	
		\begin{aligned}			
			\begin{array}{lcl}
				\transpT{X}{\proczero} & \define & \proczero \\
				\transpT{X}{\tau} & \define & \tau \\
				\transpT{X}{\inp{x}{y}} & \define & \inp{\transpT{X}{x}}{\transpT{X}{y}} \\
				\transpT{X}{\out{x}{y}} & \define & \out{\transpT{X}{x}}{\transpT{X}{y}} \\
				\transpT{X}{\pi.P} & \define & \transpT{X}{\pi}.\transpT{X}{P} \\
			\end{array}
		\end{aligned}\quad
		\begin{aligned}
			\begin{array}{lcl}
				\transpT{X}{\procchoice{P}{Q}} & \define & \procchoice{\transpT{X}{P}}{\transpT{X}{Q}} \\
				\transpT{X}{\procpar{P}{Q}} & \define & \procpar{\transpT{X}{P}}{\transpT{X}{Q}} \\
				\transpT{X}{\procres{a}{P}} & \define & \procres{\transpT{X}{a}}{\transpT{X}{P}} \\
				\transpT{X}{\proccall{A}{\vec{v}}} & \define & \proccall{B}{\transpT{X}{\vec{v}}} \\
			\end{array}
		\end{aligned}
	\end{equation*}
for $x,y,a\in\names$, $P,Q\in\procs$ and $\procdef{A}{\vec{w}}\define{}P$ and $\procdef{B}{\vec{w}}\define{}\transpT{X\cup\vec{w}}{P}$. The function for the names of a transposition is  equally defined.
\end{definition}
\end{old}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% END TRANSPOSITION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For the definition of the \findex{$\alpha$-convertibility}, a relation collecting processes which can be obtained from each other by only a finite number of replacements of bound names, we refer to \cite{caires}. Therefore, we first define the meaning of a \findex{congruence relation} on processes.

\begin{definition}[Congruence relation]%\todo{why is the process congruence a congruence? Does not fit for all in all contexts.}
\label{def_cong_rel}
A relation $\equiv{}\subseteq\procs\times\procs$ is an \findex{equivalence relation}, if
\begin{align}
	\forall P\in\procs&\colon P\equiv{}P \tag{Reflexivity} \\
	\forall P,Q\in\procs&\colon P\equiv{}Q\Rightarrow Q\equiv{}P \tag{Symmetry}\\
	\forall P,Q,R\in\procs&\colon P\equiv{}Q \wedge Q\equiv{}R \Rightarrow P\equiv{}R\tag{Transitivity}
\end{align}
holds. If such a relation is preserved under each defined operator, it is called a \findex[process!congruence]{process congruence}. In the notation according to \cite{meyer}, an equivalence relation is a process congruence if
\begin{align}
	\forall P,Q,R\in\procs&\colon P\equiv{}Q\Rightarrow \procpar{P}{R}\equiv{}\procpar{Q}{R} \tag{Cong Par R}\label{congparr}\\
	\forall P,Q,R\in\procs&\colon P\equiv{}Q\Rightarrow \procpar{R}{P}\equiv{}\procpar{R}{Q} \tag{Cong Par L}\label{congparl}\\
	\forall P,Q\in\procs,M\in\sums,\pi\;\text{prefix}&\colon P\equiv{}Q \Rightarrow \procchoice{\pi.P}{M}\equiv{}\procchoice{\pi.Q}{M}\tag{Cong Sum1 R}\label{congsum1r}\\
	\forall P,Q\in\procs,M\in\sums,\pi\;\text{prefix}&\colon P\equiv{}Q \Rightarrow \procchoice{M}{\pi.P}\equiv{}\procchoice{M}{\pi.Q}\tag{Cong Sum1 L}\label{congsum1l} \\\notag\\
	\forall M,M_1,M_2\in\sums,a\in\names&\colon \notag\\
				 M_1\equiv{}M_2 \Rightarrow\; & \procchoice{\procres{a}{M_1}}{M}\equiv{}\procchoice{\procres{a}{M_2}}{M}\tag{Cong Sum2 R}\label{congsum2r}\\
				 M_1\equiv{}M_2 \Rightarrow\; & \procchoice{M}{\procres{a}{M_1}}\equiv{}\procchoice{M}{\procres{a}{M_2}}\tag{Cong Sum2 L}\label{congsum2l}\\
	\forall P,Q\in\procs,a\in\names&\colon  P\equiv{}Q \Rightarrow \procres{a}{P}\equiv{}\procres{a}{Q}\tag{Cong Res}\label{congres}
\end{align}
holds.
\end{definition}

Since the choice operator is only defined on prefix processes or restrictions of sums, in general $\procchoice{P}{M}$ and $\procchoice{\procres{a}{P}}{M}$ is not a process. Thus, every possible choice process is covered by the (\ref{congsum1r}) respectively (\ref{congsum1l}) and (\ref{congsum2r}) respectively (\ref{congsum2l}) properties. Furthermore, note that with $M=\proczero{}$ the prefix operator is also covered by the first two sum implications and the restriction operator by the second two sum implications together with the last implication of the congruence.

By adding two additional rules, we get a relation which is preserved under the renaming of bound names within a process.

\begin{definition}[$\alpha$-convertibility]
\label{def_alpha_conv}
The least congruence relation on processes, denoted by $\alphaeq\;\subseteq\procs\times\procs$, with
	\begin{align}
		\forall P\in\procs,a\in\names{},p\nin\n{P}&: \procres{a}{P}\alphaeq{}\procres[a]{p}{P\subs{p}{a}} \tag{Alpha Res} \\
		\forall P\in\procs,x,y\in\names{},p\nin\left(\n{P}\cup\set{x}\right)&: \inp{x}{y}.P\alphaeq{}\inp{x}{p}.\left(P\subs{p}{y}\right) \tag{Alpha Inp} 
	\end{align}
is called the \findex[$\alpha$-convertibility]{$\alpha$-convertibility relation}. For all $(P,Q)\in\;\alphaeq$ we say $P$ and $Q$ are \findex{$\alpha$-convertible} and the equivalence classes are noted by $\ec{P}\in\procs_\alpha$ for all $P\in\procs$, where $\procs_\alpha$ denotes the set of all equivalence classes modulo $\alpha$-convertibility.
\end{definition}

Intuitively, we can rename the bound names within a process without changing anything of its behavior or nature. This concept can similarly be seen as the idea of local variables in programming languages. %To avoid the necessity to take a closer look at the structure of a process when determining the scope of a bound name, we introduce the following convention that the bound names of an investigated set of processes and substitutions are unique.

Since there is the possibility to change the bound names anytime we want without changing the process' behavior, we introduce the convention that the bound names of an investigated set of processes and substitutions are unique.% for a more simplified handling.

\begin{conv}[Uniqueness of bound names]
\label{conv_uni_bn}\index{uniqueness of bound names!process}
Given $P_1,\ldots,P_n\in\procs$ a collection of \picalc{} processes and a collection $\sigma_1,\ldots,\sigma_m$ of substitutions for $n,m\in\N$, we stipulate that
\begin{enumerate}
	\item $\forall{}i,j\in\set{1,\ldots,n}\;\text{with}\;i\neq{}j: \bn{P_i}\cap\bn{P_j} = \emptyset$,
	\item $\bigcup_{i\in\set{1,\ldots,n}}\bn{P_i} \cap \bigcup_{i\in\set{1,\ldots,n}}\fn{P_i} = \emptyset$,
	\item For all $i\in\set{1,\dots,n}$ and $\circ\in\set{\procpar{}{},\procchoice{}{}}$ the following implications hold
		\begin{align*}
			\begin{array}{lcll}
				P_i&=&P\circ{}Q &\Rightarrow \bn{P}\cap\bn{Q}=\emptyset \\
				P_i&=&\inp{a}{x}.P &\Rightarrow x\nin\bn{P} \\
				P_i&=&\procres{z}{P} &\Rightarrow  z\nin\bn{P}
			\end{array}
		\end{align*}
		with $P,Q\in\procs$ and $a,x,z\in\names$,
	\item $\bn{P_i}\cap\n{\sigma_j}=\emptyset$ for all $i\in{}\set{1,\ldots,n}$ and $j\in\set{1,\dots,m}$
\end{enumerate}
holds.
\end{conv}

The first condition ensures that the bound names among the processes are different, the second states that the bound names of a process and its free names and all the free names of the other processes are different, the third one ensures that the bound names differ within a process, and the last one states that the bound names of a process are different from the names of the substitutions under consideration.

Hence, any time we receive a process which violates the convention, we silently rename the bound names so that we receive a proper process.
