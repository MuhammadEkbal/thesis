% mainfile: ../Refinement.tex
\chapter{Introduction}
\pagestyle{scrheadings}	
\setcounter{page}{0}
\pagenumbering{arabic} 
\label{sec_introduction}
In many cases of modern computing it is of interest to describe and model concurrency. Computers no longer just solve a problem by subsequently working off the single tasks of their own, but they decompose and concurrently calculate the problem even together in a network. The increase in the number of CPU cores and more heavily of GPU cores within one single computer convincingly demonstrates how fundamental concurrency is for modern computing. Moreover, the rapidly increasing spread of the Internet is one of the most common examples which shows the importance of networks.

For concurrently calculating the decomposed tasks, these tasks have to be distributed to the participants. Moreover, the members have to communicate with each other, for example, for sending interrupts and sharing results. Generally, one can say, the more use of concurrency the more communication has to be done. Hence, concurrently communicating systems are rather the norm than an exception. Thus, investigating concurrency and communication are a continuing concern within modern computing.

%One well-accepted way to specify such systems are \findex[process algebra]{process algebras} like Tony Hoare's \gls{CSP} \cite{hoareOriginalCSP} and Robin Milner's \gls{CCS} \cite{milnerCCS}.
For the formal specification of such systems \findex[process!algebra]{process algebras} have been widely accepted, especially Tony Hoare's \gls{CSP} \cite{hoareOriginalCSP} and Robin Milner's \gls{CCS} \cite{milnerCCS}. Thereby, the components of the system -- for example, clients and servers -- are called processes and are described as algebraic structures. One limitation of the expressiveness of the process algebras mentioned above is the static definition of the processes. A structural modification of the process during a computation is not possible. This is taken into account in the \picalc{} defined by Robin Milner, Joachim Parrow, and David Walker in \cite{milnerParrowWalker}.

The \picalc{} is an extension of \gls{CCS} and adds the facility of expressing changes in the process structure inspired by the work of Uffe Engberg and Mogens Nielsen in \cite{engbertNielsen}. This modification of the process structure is called \emph{mobility}. Thus, with the \picalc{} we can describe and investigate concurrently communicating mobile processes. In the \picalc{}, mobility can be understood as modifications of the \emph{linking structure} of the processes.

A standard example of mobility in the \picalc{} is the connection of mobile phones to base stations. Consider, for example, two persons $P_1$ and $P_2$ carrying mobile phones. At the beginning of the setting both are separately connected to two different static base stations $S_1$ and $S_2$. Thereby, $P_1$ is connected to $S_1$ and $P_2$ is connected to the base station $S_2$. Then, we can think of two possible forms of movement. On the one hand, there is the \emph{physical mobility}. That is, a person has changed its location within the real word, which is not within the focus of the \picalc{}. On the other hand, the communication links between the base stations and the persons has changed, called \emph{virtual mobility}. Consider, for example, $P_1$ is leaving the reception area of $S_1$ while reaching the area of $S_2$. Then a new communication link between $P_1$ and $S_2$ is established and the contact to $S_1$ is disconnected. Thus, $P_1$ and $P_2$ are now both connected to $S_2$ and none of them to $S_1$. Hence, the connections between the persons and the base stations at the beginning of the setting are significantly different to the linking structure at the end. The \picalc{} treats the virtual mobility by passing channels within a communication.

Even though many variations and modifications of Milner's original \picalc{} exist and it has been investigated in many ways, the general focus is mainly on bisimulations between processes to determine their equivalence \cite{pistore}. That is, observing their behaviour and determine whether they behave identically. Thus, proving correctness requires a symmetric equivalence relation with the program and the specification within. Apart from that, it would be interesting to investigate the process' behavior like it is done in \gls{CSP} with its set-theoretical denotation for the investigation whether a process satisfies its specification. That is, we define a condition (the specification) and check if another process (the program) meets this specification by comparing their behavior collected in sets. To reach this, the sequences of events (\emph{traces}) are collected in a set and the correctness is proved by set inclusion. Thereby, there is no need for a symmetry. This approach is often called \emph{refinement}. Even though there is also a relation called simulation which does not need to be symmetrical, ``[$\ldots$] the time has come to unify the two modelling styles [(\gls{CSP} and \gls{CCS})], to enable practicing engineers to exploit a combination of their complementary advantages''\footnote{\cite{hoareWhyCSP}, page 209.} like Tony Hoare wrote in 2006. This statement is also applicable to \gls{CSP} and the \picalc{}.

Hence, the contribution of this thesis is to develop a notion of refinement for \picalc{} processes similar to the approach for \gls{CSP} in \cite{roscoe} to achieve the advantages of this modeling style. Thereby, we primarily concentrate on the \emph{trace semantics} and neglect the \emph{failures} and \emph{failures-divergence semantics}. Furthermore, we investigate the properties of this semantics to show its usability and point out its limitations.

This thesis is divided into five chapters. In \refChap{sec_preliminaries} we briefly introduce sequences and properly investigate the \picalc{} and its operational semantics (the \emph{early transition system} \cite{sangiorgi}). Thereby, a new structural form of processes -- the \emph{extended standard form} -- is introduced and it is shown that every process can be transformed into a structural congruent one in this standard form. We proceed in \refChap{sec_big-step_semantics} by defining a big-step semantics which bases on the early transition system by observing an arbitrary number of external steps within the early semantics. Subsequently, in \refChap{sec_de_sem_trace}, we introduce the trace semantics which is based on the big-steps semantics of the previous chapter. Thereby, we investigate its properties and define the refinement based on the trace semantics. Finally, the conclusion in \refChap{sec_conclusion} gives a brief summary of our results and presents ideas for future work.



%oft auch sicht sicht von reaktionen (chemical machine) aber da kann nicht das ganze verhalten usw.
\begin{old}[Milner Zitat]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Zitat Interview Milner: 2003
Even now I am talking with Tony Hoare, who is much more interested in the idea of what it means for a program to meet its specification. We are now trying to reconcile the CCS approach that regards denotations as congruence classes, and the CSP which talks about set-theoretic denotations such as failures and traces and so on, and has very nice ordering relations, so that if the specification is larger than the implementation it means that the implementation is correct. The ordering notion between processes is of course the other main important thing in process calculi. I think we want both; we want the notion of denotations, and perhaps they are congruence classes, and we want the orderings or preorderings representing improvement of, or refinement from, a specification.

> What is the inverse of these refinement relations? I suspect it is related to transactions?

I suppose there is not a symmetry here. If somebody states a specification, then what they are saying is: I want a program to satisfy this and there would be many different programs that satisfy it. To produce any one program that satisfies this is satisfactory. Given that program, you could refine it further and it would of course still satisfy the original specification because that is the refinement ordering. But coarsening it might mean that it then would not satisfy that specification that it originally did, because you would coarsen it in a different direction. So coarsening doesn't have the same pragmatic interest. I think that's a fair way of putting it.


> Yes, but isn't refinement the inverse to that? You have a command that says \"send message from x to y\" and when you refine that, it becomes \"send message from x to a, from a to b, from b to c and from c to y\" ...

I think that's a different kind of refinement. Say you state a specification in logic. You say that all communication must satisfy the following formulae. That allows a whole space of programs to satisfy that. But they will all be talking about communications at a particular level of abstraction. You've got the idea of different levels of abstraction as orthogonal to the question of refinement. Maybe some people will call abstraction refinement, maybe there's confusion ...

>Probably me who confuses things!

But I think everybody is confused about that. Different levels of abstraction is not the same thing as refining from a specification to an implementation. 
\end{old}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% OLD PROPOSAL
\begin{old}[proposal]
In many cases of modern computing it is of interest to describe and model communication, for example, the interaction between components of a computer or -- in particular in our web-based world -- communication across the network. The participating parts often behave in a concurrent manner, hence communication and concurrency are some of the fundamental concepts of computing \cite{milner}.

For the formal specification of such systems process algebras have been widely accepted, especially Robin Milner's \picalc{} described in \cite{milner}. In addition to algebras like the \gls{CCS}, also invented by Robin Milner, and Tony Hoare's \gls{CSP}, the \picalc{} provides the ability to model mobility of processes in an intuitive way, so that the facility of expressing changes in the process structure is given \cite{canal}.

Even though many variations and modifications of Milner's original \picalc{} exist and it is investigated in many ways, the general focus is mainly put on bisimulations between processes to determine their equivalence \cite{pistore}, that is, observing their behaviour and determine whether they behave identically. Apart from that it, would be interesting to distinguish processes by their different behaviour in the degree of nondeterminism and divergence like the refinement notion described by Bill Roscoe in \cite{roscoe} for CSP. 

Thus, the aim of this thesis is to develop a notion of refinement for processes of the \picalc{} and to investigate some of its properties, that is, to construct the possibility to distinguish two \picalc{} processes in the matter of their internal and external behaviour in terms of determinism and divergence. This formerly not reviewed issue is investigated in this theses.

Therefore \refChap{sec_preliminaries} gives an overview of Milner's \picalc{} with its definition and some properties. It also contains some related work \todo[inline]{...}.
\end{old}

