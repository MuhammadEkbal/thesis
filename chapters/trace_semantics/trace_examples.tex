% mainfile: ../../Refinement.tex
\begin{figure}[h!]
\lstinputlisting[language=pseudocode, mathescape]{listings/compo_comput.psc}
\caption{Compositional computation of traces $\mathtt{calc}$.}
\label{fig_comp_comput}
\end{figure}
In this section we briefly state the usage of the trace refinement by reconsidering the buffer of \refSec{sec_pi_op_sem}. Furthermore, we introduce a rudimentary idea of a first implementation of the calculation of the trace sets. For this approach we almost directly convert the compositional definitions of \refSec{sec_de_sem_trace_prop_comp} to pseudocode.

\begin{figure}[H]
\lstinputlisting[language=pseudocode, mathescape]{listings/compo_comput_inp.psc}
\caption{Compositional computation of traces $\mathtt{calc}_{\mathtt{inp}}$.}
\label{fig_comp_comput_inp}
\end{figure}

Thus, in \refFig{fig_comp_comput} we list the main calculation algorithm, which decides by the process' structure, which sub-algorithm should be used. All algorithms take a recursion-free process and an finite subset of names as input parameters. The limitation to recursion-free processes depends on the circumstances that we neither have any fix-point algorithm up to now nor showed that one exists. The second input parameter is invented for the calculation of the traces of an input process and denotes the names which can be send from the environment to the system. First of all the process is transformed in extended standard form for a possible application of the algorithm for the parallel composition. The algorithm for an inaction, a choice, and an output process are already given in this listing. They are all the direct translation of the definitions of \refSec{sec_de_sem_trace_prop_comp}.

In \refFig{fig_comp_comput_inp} the algorithm for calculating the traces of an input process is given. In this algorithm we can understand the need of the restriction to a finite set of names. Since all names which can possibly be send from the environment to the process are collected in $\relNames$, we know that only those names and the names which occur free in the process under consideration can possibly establish new communication. Thus, we only have to calculate traces for the processes, where the subject of the input prefix is substituted by such names. To optimize the number of calculations, we take advantage of \refCor{cor_subst_trace_inclusion}.

\begin{figure}[h!]
\lstinputlisting[language=pseudocode, mathescape]{listings/compo_comput_par.psc}
\caption{Compositional computation of traces $\mathtt{calc}_{\mathtt{par}}$.}
\label{fig_comp_comput_par}
\end{figure} %$\mathtt{max}$ maximal deduction steps to reach $T_1'$ and $T_2'$;

The algorithm for calculating the traces of the parallel composition is listed in \refFig{fig_comp_comput_par}. Mainly, the algorithm uses \refDef{def_idx_trace_sets} to calculated the sets of the inductive parallel composition of the traces of $P_1$ and $P_2$. This is also a straightforward translation of this definition.

\begin{figure}[h]
\lstinputlisting[language=pseudocode, mathescape]{listings/compo_comput_res.psc}
\caption{Compositional computation of traces $\mathtt{calc}_{\mathtt{res}}$.}
\label{fig_comp_comput_res}
\end{figure}

\refFig{fig_comp_comput_res} show the computation of the traces of a restriction. This computation directly yields from \refConj{conj_compositionality_traces_res}.

Utilizing the approach, we can investigate the buffer defined in \refSec{sec_pi_op_sem}. Since we do not have any algorithm for computing processes with recursive calls, we have to unfold the examples. For a clearer arrangement we do not write the processes as a whole, but naming parts of the process separately. Those naming do not have to be understood as a recursive call without parameter. First of all we reconsider the one cell buffer of \cite{milner} unfolded once:

\[ONE\_CELL\define\inp{i}{v_1}.\out{o}{v_1}.\inp{i}{v_2}.\out{o}{v_2}.\]
With attention to \refFig{fig_ts_buffer_one_cell} or by using the algorithm, we directly see that 
\[\traces[ONE\_CELL]=\pref{\set[v_1,v_2\in\names]{\seq{\inpa{i}{v_1},\outa{o}{v_1},\inpa{i}{v_2},\outa{o}{v_2}}}}.\]
Furthermore, we can omit the recursive calls of the second buffer and reach
\[TWO\_CELL\define\procchoice{\inp{i}{v_1}.\out{o}{v_1}.\inp{i}{v_2}.\out{o}{v_2}}{\inp{i}{v_1'}.\inp{i}{v_2'}.\out{o}{v_1'}.\out{o}{v_2'}}.\]
Thus, the set of traces is again easily to compute:
\begin{align*}
\begin{array}{rcl}
 \traces[TWO\_CELL]=&\pref{\set[v_1,v_2\in\names]{\seq{\inpa{i}{v_1},\outa{o}{v_1},\inpa{i}{v_2},\out{o}{v_2}}}} \\
\cup&\pref{\set[v_1,v_2\in\names]{\seq{\inpa{i}{v_1},\inpa{i}{v_2},\outa{o}{v_1},\outa{o}{v_2}}}}.
\end{array}
\end{align*}
Thus, since $\traces[ONE\_CELL]\subseteq{}\traces[TWO\_CELL]$ holds, we know that the $ONE\_CELL$ buffer refines the $TWO\_CELL$ buffer. That is $TWO\_CELL \refi ONE\_CELL$. As expected this does not hold the other way round.

We can now think of our invented $TWO\_CELL$ buffer as an implementation of Milner's $FIFO$ buffer defined in \refEx{ex_two_cell_buffer_milner}. Thus, we would like that our implementation satisfy the specification of a FIFO buffer by Milner. Therefore, we unfold the buffer once:
\[FIFO\define\procres[()]{c}{\procpar{\inp{i}{v_1}.\out{c}{v_1}.\inp{i}{v_2}.\out{c}{v_2}}{\inp{c}{v_1'}.\out{o}{v_1'}.\inp{c}{v_2'}.\out{o}{v_2'}}}.\]
So we see, that the channel $c$ is private and hence, only the traces where a communication over $c$ has been established are within the set of traces. All traces may not so obviously be read from the definition of $FIFO$. So we implemented the algorithm presented at the beginning of this section. Thus, we get:
\begin{align*}
\begin{array}{rcl}
 \traces[FIFO]=&\pref{\set[v_1,v_2\in\names]{\seq{\inpa{i}{v_1},\outa{o}{v_1},\inpa{i}{v_2},\out{o}{v_2}}}} \\
\cup&\pref{\set[v_1,v_2\in\names]{\seq{\inpa{i}{v_1},\inpa{i}{v_2},\outa{o}{v_1},\outa{o}{v_2}}}}.
\end{array}
\end{align*}
Hence, we know that the $TWO\_CELL$ and the $FIFO$ buffer are trace equivalent and therefore for this unfolding the $TWO\_CELL$ buffer satisfy its specification. But if we unfold the two cell buffer of \refEx{ex_two_cell_buffer_mine} once and the FIFO buffer triply so that they are both able to perform four read and write passes, we see that we did not developed a FIFO buffer with the same behavior than Milner's one. So, we unfold our two cell buffer once and so define $TC$ with:
\begin{align*}
	\begin{array}{rcl}
TC&\define& \inp{i}{v_1}.\inp{i}{v_2}.\out{o}{v_1}.\out{o}{v_2}.\left(\procchoice{B_1}{B_2}\right) \\
			&+& \inp{i}{v_1'}.\out{o}{v_1'}.\inp{i}{v_2'}.\out{o}{v_2'}.\left(\procchoice{B_3}{B_4}\right) \\
B_1&\define&\inp{i}{v_3}.\inp{i}{v_4}.\out{o}{v_3}.\out{o}{v_4} \\
B_2&\define&\inp{i}{v_3'}.\out{o}{v_3'}.\inp{i}{v_4'}.\out{o}{v_4'} \\
B_3&\define&\inp{i}{v_3''}.\inp{i}{v_4''}.\out{o}{v_3''}.\out{o}{v_4''} \\
B_4&\define&\inp{i}{v_3'''}.\out{o}{v_3'''}.\inp{i}{v_4'''}.\out{o}{v_4'''}.
\end{array}
\end{align*}
Furthermore, with $F_2$ we denote the triply unfolded FIFO buffer with:
\begin{align*}
\begin{array}{rcl}
F_2&\define&\procres[()]{c}{\procpar{\inp{i}{v_1}.\out{c}{v_1}.\inp{i}{v_2}.\out{c}{v_2}.B_1}{\inp{c}{v_1'}.\out{o}{v_1'}.\inp{c}{v_2'}.\out{o}{v_2'}.B_2}}\\
B_1&\define&\inp{i}{v_3}.\out{c}{v_3}.\inp{i}{v_4}.\out{c}{v_4} \\
B_2&\define&\inp{c}{v_3'}.\out{o}{v_3'}.\inp{c}{v_4'}.\out{o}{v_4'}.
\end{array}
\end{align*}
The traces for the two cell buffer $TC$ are again readable of the definition, since the traces of the choice operator are just the union of the separate parts. Thus, we know
\begin{align*}
	\begin{array}{rcl}
		\traces[TC]&=&\pref{\set[v_1,\ldots{},v_4\in\names]{\seq{\inpa{i}{v_1},\inpa{i}{v_2},\outa{o}{v_1},\outa{o}{v_2},\inpa{i}{v_3},\inpa{i}{v_4},\outa{o}{v_3},\outa{o}{v_4}}}} \\
				&\cup&\pref{\set[v_1,\ldots{},v_4\in\names]{\seq{\inpa{i}{v_1},\inpa{i}{v_2},\outa{o}{v_1},\outa{o}{v_2},\inpa{i}{v_3},\outa{o}{v_3},\inpa{i}{v_4},\outa{o}{v_4}}}} \\
				&\cup&\pref{\set[v_1,\ldots{},v_4\in\names]{\seq{\inpa{i}{v_1},\outa{o}{v_1},\inpa{i}{v_2},\outa{o}{v_2},\inpa{i}{v_3},\inpa{i}{v_4},\outa{o}{v_3},\outa{o}{v_4}}}} \\
				&\cup&\pref{\set[v_1,\ldots{},v_4\in\names]{\seq{\inpa{i}{v_1},\outa{o}{v_1},\inpa{i}{v_2},\outa{o}{v_2},\inpa{i}{v_3},\outa{o}{v_3},\inpa{i}{v_4},\outa{o}{v_4}}}} 
	\end{array}
\end{align*}
holds. For the FIFO buffer $F_2$ we needed to adapt our rudimentary implementation a bit for this special case. Otherwise the computer needed more than $35$GB RAM (including swap), although we swap all actual not needed sets of the inductive parallel composition to the hard drive. Thus, since we know that the input variables never are used as channels we always take the first case in \refFig{fig_comp_comput_inp}. That is, we are treating the input variables in any case as not free within the process. Furthermore, we just compute the traces for four names possible as input variable. At least, for the parallel composition we added another condition for adding traces to the sets of the inductive parallel composition. Since we know that after computing the traces of the parallel composition, we will in this case filter out all traces containing the name $c$ with the restriction algorithm. Thus, we already omitting them during the computation of the parallel composition. This approach already calculates $463761$ traces for the inductive parallel composition with index $0$ and ends up by $24505$ traces. This all leads to the following result of the set of traces for the $F_2$ FIFO buffer:
\begin{align*}
	\begin{array}{rcl}
		\traces[F_2]&=&\pref{\set[v_1,\ldots{},v_4\in\names]{\seq{\inpa{i}{v_1},\outa{o}{v_1},\inpa{i}{v_2},\outa{o}{v_2},\inpa{i}{v_3},\outa{o}{v_3},\inpa{i}{v_4},\outa{o}{v_4}}}} \\
&\cup&\pref{\set[v_1,\ldots{},v_4\in\names]{\seq{\inpa{i}{v_1},\inpa{i}{v_2},\outa{o}{v_1},\inpa{i}{v_3},\outa{o}{v_2},\inpa{i}{v_4},\outa{o}{v_3},\outa{o}{v_4}}}} \\
&\cup&\pref{\set[v_1,\ldots{},v_4\in\names]{\seq{\inpa{i}{v_1},\inpa{i}{v_2},\outa{o}{v_1},\inpa{i}{v_3},\outa{o}{v_2},\outa{o}{v_3},\inpa{i}{v_4},\outa{o}{v_4}}}} \\
&\cup&\pref{\set[v_1,\ldots{},v_4\in\names]{\seq{\inpa{i}{v_1},\outa{o}{v_1},\inpa{i}{v_2},\outa{o}{v_2},\inpa{i}{v_3},\inpa{i}{v_4},\outa{o}{v_3},\outa{o}{v_4}}}} \\
&\cup&\pref{\set[v_1,\ldots{},v_4\in\names]{\seq{\inpa{i}{v_1},\inpa{i}{v_2},\outa{o}{v_1},\outa{o}{v_2},\inpa{i}{v_3},\inpa{i}{v_4},\outa{o}{v_3},\outa{o}{v_4}}}} \\
&\cup&\pref{\set[v_1,\ldots{},v_4\in\names]{\seq{\inpa{i}{v_1},\outa{o}{v_1},\inpa{i}{v_2},\inpa{i}{v_3},\outa{o}{v_2},\inpa{i}{v_4},\outa{o}{v_3},\outa{o}{v_4}}}} \\
&\cup&\pref{\set[v_1,\ldots{},v_4\in\names]{\seq{\inpa{i}{v_1},\inpa{i}{v_2},\outa{o}{v_1},\outa{o}{v_2},\inpa{i}{v_3},\outa{o}{v_3},\inpa{i}{v_4},\outa{o}{v_4}}}} \\
&\cup&\pref{\set[v_1,\ldots{},v_4\in\names]{\seq{\inpa{i}{v_1},\outa{o}{v_1},\inpa{i}{v_2},\inpa{i}{v_3},\outa{o}{v_2},\outa{o}{v_3},\inpa{i}{v_4},\outa{o}{v_4}}}}. 
	\end{array}
\end{align*}

Thus, we get that $F_2$ does satisfy the specification of a FIFO buffer, but since for example $\seq{\inpa{i}{v_1},\inpa{i}{v_2},\outa{o}{v_1},\inpa{i}{v_3},\outa{o}{v_2},\outa{o}{v_3},\inpa{i}{v_4},\outa{o}{v_4}}\nin\traces[TC]$, we know those buffer are not trace equivalent.

For a buffer not satisfying the specification of Milner's FIFO buffer, we consider
\begin{align*}
\begin{array}{rcl}
	BUF&\define&\inp{i}{v_1}.\out{o}{v_1}.\inp{i}{v_2}.\out{o}{v_2}\\
			& +& \inp{i}{v_1'}.\inp{i}{v_2'}.\out{o}{v_1'}.\out{o}{v_2'}\\
			& +& \inp{i}{v_1''}.\inp{i}{v_2''}.\out{o}{v_2''}.\out{o}{v_1''}.
\end{array}
\end{align*}
Thus, we know
\begin{align*}
\begin{array}{rcl}
 \traces[BUF]=&\pref{\set[v_1,v_2\in\names]{\seq{\inpa{i}{v_1},\outa{o}{v_1},\inpa{i}{v_2},\out{o}{v_2}}}} \\
\cup&\pref{\set[v_1,v_2\in\names]{\seq{\inpa{i}{v_1},\inpa{i}{v_2},\outa{o}{v_1},\outa{o}{v_2}}}}\\
\cup&\pref{\set[v_1,v_2\in\names]{\seq{\inpa{i}{v_1},\inpa{i}{v_2},\outa{o}{v_2},\outa{o}{v_1}}}}.
\end{array}
\end{align*}
holds. Hence, $BUF$ is not satisfying the specification of $FIFO$, since for example $\seq{\inpa{i}{v_1},\inpa{i}{v_2},\outa{o}{v_2},\outa{o}{v_1}}\nin\traces[FIFO]$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% START SOME OLD EXAMPLES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{old}{example of operational semantics chapter with things needed for refinement}
%  * <i valueB,i valueA,o_<valueB>,o_<valueA>>,
%         * <i valueA,i valueB,o_<valueA>,o_<valueB>>,
%         * <i valueA,o_<valueA>,i valueB,o_<valueB>>,
%         * <i valueB,o_<valueB>,i valueA,o_<valueA>>
\begin{align*}
  \begin{array}{rcl}
     B   &\define{}&\procres[()]{c_1}{\procpar{B_1}{B_2}} \\
     B_1 &\define{}&\inp{i}{v_1}.\out{c_1}{v_1}.B_3 \\
     B_2 &\define{}&\inp{c_1}{v_2}.\out{o}{v_2}.B_4 
  \end{array}
\end{align*}

\begin{equation*}	
	\begin{aligned}	
  \begin{array}{rcl}
     B_3 &\define{}&\procres[()]{c_2}{\procpar{B_5}{B_6}} \\
     B_5 &\define{}&\inp{i}{v_3}.\out{c_2}{v_3} \\
     B_6 &\define{}&\inp{c_2}{v_4}.\out{c_1}{v_4} 
  \end{array}
\end{aligned}\quad\quad
\begin{aligned}
  \begin{array}{rcl}
     B_4   &\define{}&\procres[()]{c_3}{\procpar{B_7}{B_8}} \\
     B_7 &\define{}&\inp{c_1}{v_5}.\out{c_3}{v_5} \\
     B_8 &\define{}&\inp{c_3}{v_6}.\out{o}{v_6} 
  \end{array}
\end{aligned}
\end{equation*}
Thus, 
\begin{align*}
B\struc\procres{}{}\;c_1,c_2,c_3\bigl(\inp{i}{v_1}.\out{c_1}{v_1}.\bigl(\procpar{\inp{i}{v_3}.\out{c_2}{v_3} }{\inp{c_2}{v_4}.\out{c_1}{v_4}}\bigr) \\
\;\mid\; \inp{c_1}{v_2}.\out{o}{v_2}.\bigl(\procpar{\inp{c_1}{v_5}.\out{c_3}{v_5}}{\inp{c_3}{v_6}.\out{o}{v_6}}\bigr)\bigr)
\end{align*}

thewn@apu:~/masterarbeit/git/impl/REF/dist java -Xmx50g -jar REF.jar 
P0\define{}\procres[()]{c1}{P0'\define{}\procpar{P1\define{}\inp{i}{v1}.P1'\define{}\out{c1}{v1}.P3\define{}\procres[()]{c2}{P3'\define{}\procpar{P5\define{}\inp{i}{v3}.P5'\define{}\out{c2}{v3}.P9\define{}\procres[()]{c2}{P9'\define{}\procpar{P13\define{}\inp{i}{v7}.P13'\define{}\out{c4}{v7}.\proczero{}}{P14\define{}\inp{c4}{v8}.P14'\define{}\out{c2}{v8}.\proczero{}}}}{P6\define{}\inp{c2}{v4}.P6'\define{}\out{c1}{v4}.P10\define{}\procres[()]{c3}{P10'\define{}\procpar{P15\define{}\inp{c2}{v9}.P15'\define{}\out{c5}{v9}.\proczero{}}{P16\define{}\inp{c5}{v10}.P16'\define{}\out{c1}{v10}.\proczero{}}}}}}{P2\define{}\inp{c1}{v2}.P2'\define{}\out{o}{v2}.P4\define{}\procres[()]{c3}{P4'\define{}\procpar{P7\define{}\inp{c1}{v5}.P7'\define{}\out{c3}{v5}.P11\define{}\procres[()]{c2}{P11'\define{}\procpar{P17\define{}\inp{c1}{v11}.P17'\define{}\out{c6}{v11}.\proczero{}}{P18\define{}\inp{c6}{v12}.P18'\define{}\out{c3}{v12}.\proczero{}}}}{P8\define{}\inp{c3}{v6}.P8'\define{}\out{o}{v6}.P12\define{}\procres[()]{c3}{P12'\define{}\procpar{P19\define{}\inp{c3}{v13}.P19'\define{}\out{c7}{v13}.\proczero{}}{P20\define{}\inp{c7}{v14}.20'\define{}\out{o}{v14}.\proczero{}}}}}}}
P1\define{}\inp{i}{v1}.P1'\define{}\out{c1}{v1}.P3\define{}\procres[()]{c2}{P3'\define{}\procpar{P5\define{}\inp{i}{v3}.P5'\define{}\out{c2}{v3}.P9\define{}\procres[()]{c2}{P9'\define{}\procpar{P13\define{}\inp{i}{v7}.P13'\define{}\out{c4}{v7}.\proczero{}}{P14\define{}\inp{c4}{v8}.P14'\define{}\out{c2}{v8}.\proczero{}}}}{P6\define{}\inp{c2}{v4}.P6'\define{}\out{c1}{v4}.P10\define{}\procres[()]{c3}{P10'\define{}\procpar{P15\define{}\inp{c2}{v9}.P15'\define{}\out{c5}{v9}.\proczero{}}{P16\define{}\inp{c5}{v10}.P16'\define{}\out{c1}{v10}.\proczero{}}}}}
P2\define{}\inp{c1}{v2}.P2'\define{}\out{o}{v2}.P4\define{}\procres[()]{c3}{P4'\define{}\procpar{P7\define{}\inp{c1}{v5}.P7'\define{}\out{c3}{v5}.P11\define{}\procres[()]{c2}{P11'\define{}\procpar{P17\define{}\inp{c1}{v11}.P17'\define{}\out{c6}{v11}.\proczero{}}{P18\define{}\inp{c6}{v12}.P18'\define{}\out{c3}{v12}.\proczero{}}}}{P8\define{}\inp{c3}{v6}.P8'\define{}\out{o}{v6}.P12\define{}\procres[()]{c3}{P12'\define{}\procpar{P19\define{}\inp{c3}{v13}.P19'\define{}\out{c7}{v13}.\proczero{}}{P20\define{}\inp{c7}{v14}.20'\define{}\out{o}{v14}.\proczero{}}}}}
P3\define{}\procres[()]{c2}{P3'\define{}\procpar{P5\define{}\inp{i}{v3}.P5'\define{}\out{c2}{v3}.P9\define{}\procres[()]{c2}{P9'\define{}\procpar{P13\define{}\inp{i}{v7}.P13'\define{}\out{c4}{v7}.\proczero{}}{P14\define{}\inp{c4}{v8}.P14'\define{}\out{c2}{v8}.\proczero{}}}}{P6\define{}\inp{c2}{v4}.P6'\define{}\out{c1}{v4}.P10\define{}\procres[()]{c3}{P10'\define{}\procpar{P15\define{}\inp{c2}{v9}.P15'\define{}\out{c5}{v9}.\proczero{}}{P16\define{}\inp{c5}{v10}.P16'\define{}\out{c1}{v10}.\proczero{}}}}}
P4\define{}\procres[()]{c3}{P4'\define{}\procpar{P7\define{}\inp{c1}{v5}.P7'\define{}\out{c3}{v5}.P11\define{}\procres[()]{c2}{P11'\define{}\procpar{P17\define{}\inp{c1}{v11}.P17'\define{}\out{c6}{v11}.\proczero{}}{P18\define{}\inp{c6}{v12}.P18'\define{}\out{c3}{v12}.\proczero{}}}}{P8\define{}\inp{c3}{v6}.P8'\define{}\out{o}{v6}.P12\define{}\procres[()]{c3}{P12'\define{}\procpar{P19\define{}\inp{c3}{v13}.P19'\define{}\out{c7}{v13}.\proczero{}}{P20\define{}\inp{c7}{v14}.20'\define{}\out{o}{v14}.\proczero{}}}}}
P5\define{}\inp{i}{v3}.P5'\define{}\out{c2}{v3}.P9\define{}\procres[()]{c2}{P9'\define{}\procpar{P13\define{}\inp{i}{v7}.P13'\define{}\out{c4}{v7}.\proczero{}}{P14\define{}\inp{c4}{v8}.P14'\define{}\out{c2}{v8}.\proczero{}}}
P6\define{}\inp{c2}{v4}.P6'\define{}\out{c1}{v4}.P10\define{}\procres[()]{c3}{P10'\define{}\procpar{P15\define{}\inp{c2}{v9}.P15'\define{}\out{c5}{v9}.\proczero{}}{P16\define{}\inp{c5}{v10}.P16'\define{}\out{c1}{v10}.\proczero{}}}
P7\define{}\inp{c1}{v5}.P7'\define{}\out{c3}{v5}.P11\define{}\procres[()]{c2}{P11'\define{}\procpar{P17\define{}\inp{c1}{v11}.P17'\define{}\out{c6}{v11}.\proczero{}}{P18\define{}\inp{c6}{v12}.P18'\define{}\out{c3}{v12}.\proczero{}}}
P8\define{}\inp{c3}{v6}.P8'\define{}\out{o}{v6}.P12\define{}\procres[()]{c3}{P12'\define{}\procpar{P19\define{}\inp{c3}{v13}.P19'\define{}\out{c7}{v13}.\proczero{}}{P20\define{}\inp{c7}{v14}.20'\define{}\out{o}{v14}.\proczero{}}}
Loop startet: 1times.
Calculation idx_0 for 1 and 1
idx_0: 1
idx_i: 2
idx: 2
idx_i: 5
idx: 7
idx_i: 7
idx: 14
idx_i: 6
idx: 20
idx_i: 0
idx: 20
Final trace count: 20
Restriction startet: 1times.
Restriction of 20 traces.
Resultin in: 9 traces.
Loop startet: 2times.
Calculation idx_0 for 1 and 1
idx_0: 1
idx_i: 2
idx: 2
idx_i: 5
idx: 7
idx_i: 7
idx: 14
idx_i: 6
idx: 20
idx_i: 0
idx: 20
Final trace count: 20
Restriction startet: 2times.
Restriction of 20 traces.
Resultin in: 20 traces.
Loop startet: 3times.
Calculation idx_0 for 9 and 20
idx_0: 180
idx_i: 360
idx: 360
idx_i: 900
idx: 1260
idx_i: 1800
idx: 3060
idx_i: 3750
idx: 6810
idx_i: 6966
idx: 13776
idx_i: 11697
idx: 25473
idx_i: 17442
idx: 42915
idx_i: 22494
idx: 65409
idx_i: 23730
idx: 89139
idx_i: 18480
idx: 107619
idx_i: 8316
idx: 115935
idx_i: 0
idx: 115935
Final trace count: 115935
Restriction startet: 3times.
Restriction of 115935 traces.
Resultin in: 3273 traces.
Loop startet: 4times.
Calculation idx_0 for 1 and 1
idx_0: 1
idx_i: 2
idx: 2
idx_i: 5
idx: 7
idx_i: 7
idx: 14
idx_i: 6
idx: 20
idx_i: 0
idx: 20
Final trace count: 20
Restriction startet: 4times.
Restriction of 20 traces.
Resultin in: 20 traces.
Loop startet: 5times.
Calculation idx_0 for 1 and 1
idx_0: 1
idx_i: 2
idx: 2
idx_i: 5
idx: 7
idx_i: 7
idx: 14
idx_i: 6
idx: 20
idx_i: 0
idx: 20
Final trace count: 20
Restriction startet: 5times.
Restriction of 20 traces.
Resultin in: 2 traces.
Loop startet: 6times.
Calculation idx_0 for 20 and 2
idx_0: 40
idx_i: 80
idx: 80
idx_i: 200
idx: 280
idx_i: 400
idx: 680
idx_i: 776
idx: 1456
idx_i: 1380
idx: 2836
idx_i: 2194
idx: 5030
idx_i: 2992
idx: 8022
idx_i: 3332
idx: 11354
idx_i: 2751
idx: 14105
idx_i: 1260
idx: 15365
idx_i: 0
idx: 15365
Final trace count: 15365
Restriction startet: 6times.
Restriction of 15365 traces.
Resultin in: 1190 traces.
Loop startet: 7times.
Calculation idx_0 for 3273 and 1190
idx_0: 3894870
idx_i: 7789740
idx: 7789740
idx_i: 19474350
idx: 27264090
idx_i: 38948700
idx: 66212790
idx_i: 90080580
Killed


\input{./images/transitionsystems/op_sem_buffer_one_cell}
To explain this definition, it is helpful to reactivate the definitions of a buffer with one and with two cells of \refChap{sec_preliminaries} and their operational semantics of \refChap{sec_pi_op_sem}. 

First of all, the one cell buffer $B_1$, which was defined by Milner in \cite{milner}, with one value $val$ and two channels $in$ and $out$ to store respectively loads the value:
\begin{align*}
	\procdef{B_1}{in,out}&\define\inp{in}{val}.\proccall{O_1}{val,in,out} \\
	\procdef{O_1}{val,in,out}&\define\out{out}{val}.\proccall{B_1}{in,out}
\end{align*}
Since the buffer uses recursive calls to be ready again after one pass of storage and loading, the traces have to be infinite. With attention to \refFig{fig_ts_buffer_one_cell} for the traces of the one cell buffer holds:
\[\traces[\procdef{B_1}{in,out}] = \pref{\set[n\in\names]{\seq{\inpa{in}{n},\outa{out}{n}}}^*}\]
If the buffer is extended to a buffer with two cells and the fifo strategy, one possible modeling could be process $B_2$:
\begin{align*}
	\procdef{B_2}{in,out}&\define{\procchoice{\proccall{C_1}{in,out}}{\proccall{C_2}{in,out}}}  \\
	\procdef{C_1}{in,out}&\define\inp{in}{val_1}.\inp{in}{val_2}.\out{out}{val_1}.\out{out}{val_2}.\proccall{B_2}{in,out}	\\
	\procdef{C_2}{in,out}&\define\inp{in}{val_1}.\out{out}{val_1}.\proccall{B_2}{in,out}	
\end{align*}
\input{./images/transitionsystems/op_sem_buffer_fifo_1}
Since this buffer can also use just one cell, it has the same behavior as $B_1$; but with its second cell there is a bit more behavior added. With the properties of the trace semantics or a look at \refFig{fig_ts_buffer_fifo_1} the trace semantics of buffer $B_2$ evolves to:
\begin{align*}
	\traces[\procdef{B_2}{in,out}]=&\pref{\set[n\in\names]{\seq{\inpa{in}{n},\outa{out}{n}}}^*} \\
						\cup &\pref{\set[x,y\in\names]{\seq{\inpa{in}{x},\inpa{in}{y},\outa{out}{x},\outa{out}{y}}}^*}.
\end{align*}
So $B_1$ refines $B_2$ ($\procdef{B_2}{in,out}\refi\procdef{B_1}{in,out}$), because $\traces[\procdef{B_1}{in,out}] \subset \traces[\procdef{B_2}{in,out}]$.

It is also possible to define a fifo buffer with two cells, as a linked list:
\begin{align*}
	\procdef{FIFO}{in,out}&\define\procres[a]{com}{\procpar{\proccall{B_3}{in,com}}{\proccall{B_3}{com,out}}}\\
	\procdef{B_3}{in,out}&\define\inp{in}{val}.\proccall{O_2}{val,in,out} \\
	\procdef{O_2}{val,in,out}&\define\out{out}{val}.\proccall{B_3}{in,out}
\end{align*}
\todo{this should not be true, just $FIFO\refi{}B_2$.}
Those two fifo buffer are trace equivalent ($\traces[\procdef{B_2}{in,out}]=\traces[\procdef{FIFO}{in,out}]$). This could be helpful if one buffer has a proven property over its external behavior, then it is also known, that the other process fulfills the same property.
\todo[inline]{for finite traces adapted milners example with a parallel process modelling a counter und adding an output value for the recursive call}
\end{old}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% END SOME OLD EXAMPLES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
